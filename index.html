<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI íšŒì˜ë¡ ìš”ì•½</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }
        .recording { animation: pulse 1.5s infinite; }
        .saved-indicator { transition: opacity 1s; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white rounded-2xl shadow-lg p-6 md:p-8 w-full max-w-2xl">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-blue-600">ğŸ™ï¸ AI íšŒì˜ë¡ ìš”ì•½</h1>
            <p class="text-gray-500 mt-2">íšŒì˜ ë…¹ìŒ ë˜ëŠ” íŒŒì¼ ì—…ë¡œë“œ í›„ AIë¡œ ìš”ì•½í•˜ê³  ê³µìœ í•˜ì„¸ìš”.</p>
        </header>

        <div class="space-y-4 mb-6">
            <div>
                <label for="openai_key" class="block text-sm font-medium text-gray-700">OpenAI API Key (Whisper ìš©)</label>
                <div class="relative mt-1">
                    <input type="password" id="openai_key" class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="sk-...">
                    <span id="openai_saved" class="saved-indicator absolute right-3 top-2 text-xs text-green-500 opacity-0">Saved!</span>
                </div>
            </div>
            <div>
                <label for="google_key" class="block text-sm font-medium text-gray-700">Google AI API Key (Gemini ìš©)</label>
                <div class="relative mt-1">
                    <input type="password" id="google_key" class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="AIza...">
                    <span id="google_saved" class="saved-indicator absolute right-3 top-2 text-xs text-green-500 opacity-0">Saved!</span>
                </div>
            </div>
            <p class="text-xs text-gray-500 text-center">ì…ë ¥í•˜ì‹  í‚¤ëŠ” ë¸Œë¼ìš°ì €ì— ì•ˆì „í•˜ê²Œ ì €ì¥ë˜ì–´ ë‹¤ìŒ ë°©ë¬¸ ì‹œ ìë™ìœ¼ë¡œ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.</p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- ì‹¤ì‹œê°„ ë…¹ìŒ ì„¹ì…˜ -->
            <div class="text-center p-4 border rounded-lg">
                <h2 class="font-semibold mb-4">ğŸ”´ ì‹¤ì‹œê°„ ë…¹ìŒ</h2>
                <button id="recordBtn" class="w-24 h-24 rounded-full bg-red-500 text-white flex flex-col items-center justify-center mx-auto transition-colors duration-300 hover:bg-red-600">
                    <span>ë…¹ìŒ</span>
                    <span id="timer" class="text-xs mt-1">00:00</span>
                </button>
            </div>
            <!-- íŒŒì¼ ì—…ë¡œë“œ ì„¹ì…˜ -->
            <div class="text-center p-4 border rounded-lg flex flex-col justify-center">
                <h2 class="font-semibold mb-4">ğŸ“ íŒŒì¼ ì—…ë¡œë“œ</h2>
                <input type="file" id="fileUploader" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept="audio/*">
            </div>
        </div>

        <div id="status" class="mt-6 text-center font-semibold text-gray-600 min-h-[24px]"></div>

        <div id="result-container" class="mt-4 hidden">
            <h3 class="text-xl font-bold mb-2">âœ¨ ìš”ì•½ ê²°ê³¼</h3>
            <div id="result" class="whitespace-pre-wrap bg-gray-50 p-4 rounded-lg border max-h-60 overflow-y-auto"></div>
            <div class="mt-4 flex justify-center gap-4">
                <button id="copyBtn" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600">ë³¸ë¬¸ ë³µì‚¬</button>
                <button id="shareBtn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600">ê³µìœ í•˜ê¸°</button>
            </div>
        </div>
    </div>

    <script>
        const openaiKeyEl = document.getElementById('openai_key');
        const googleKeyEl = document.getElementById('google_key');
        const recordBtn = document.getElementById('recordBtn');
        const timerEl = document.getElementById('timer');
        const fileUploader = document.getElementById('fileUploader');
        const statusEl = document.getElementById('status');
        const resultContainerEl = document.getElementById('result-container');
        const resultEl = document.getElementById('result');
        const copyBtn = document.getElementById('copyBtn');
        const shareBtn = document.getElementById('shareBtn');
        const openaiSavedEl = document.getElementById('openai_saved');
        const googleSavedEl = document.getElementById('google_saved');

        let mediaRecorder, audioChunks = [], isRecording = false, timerInterval, seconds = 0;

        // --- í˜ì´ì§€ ë¡œë“œ ì‹œ ì €ì¥ëœ API í‚¤ ë¶ˆëŸ¬ì˜¤ê¸° ---
        window.addEventListener('DOMContentLoaded', () => {
            openaiKeyEl.value = localStorage.getItem('openaiApiKey') || '';
            googleKeyEl.value = localStorage.getItem('googleApiKey') || '';
        });

        // --- API í‚¤ ì…ë ¥ ì‹œ ìë™ìœ¼ë¡œ ì €ì¥í•˜ê³  í”¼ë“œë°± í‘œì‹œ ---
        function handleKeyInput(element, keyName) {
            localStorage.setItem(keyName, element.value);
            const savedIndicator = element.nextElementSibling;
            savedIndicator.style.opacity = '1';
            setTimeout(() => { savedIndicator.style.opacity = '0'; }, 2000);
        }
        openaiKeyEl.addEventListener('input', () => handleKeyInput(openaiKeyEl, 'openaiApiKey'));
        googleKeyEl.addEventListener('input', () => handleKeyInput(googleKeyEl, 'googleApiKey'));

        // --- ë…¹ìŒ ê¸°ëŠ¥ ---
        recordBtn.addEventListener('click', async () => {
            if (!checkApiKeys()) return;
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                    mediaRecorder.onstop = () => processAudio(new Blob(audioChunks, { type: 'audio/webm' }), 'recording.webm');
                    mediaRecorder.start();
                    
                    recordBtn.classList.add('recording');
                    isRecording = true;
                    startTimer();
                    statusEl.textContent = 'ğŸ”´ ë…¹ìŒ ì¤‘ì…ë‹ˆë‹¤...';
                    resultContainerEl.classList.add('hidden');
                } catch (err) {
                    statusEl.textContent = "ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.";
                }
            } else {
                mediaRecorder.stop();
                recordBtn.classList.remove('recording');
                isRecording = false;
                stopTimer();
            }
        });

        // --- íŒŒì¼ ì—…ë¡œë“œ ê¸°ëŠ¥ ---
        fileUploader.addEventListener('change', (event) => {
            if (!checkApiKeys()) {
                event.target.value = '';
                return;
            }
            const file = event.target.files[0];
            if (file) {
                processAudio(file, file.name);
            }
        });

        // --- í•µì‹¬ ì²˜ë¦¬ ë¼ìš°í„° ---
        async function processAudio(audioBlob, fileName) {
            statusEl.textContent = 'â³ ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...';
            resultContainerEl.classList.add('hidden');
            const MAX_SIZE = 25 * 1024 * 1024; // 25MB

            if (audioBlob.size > MAX_SIZE) {
                const proceed = confirm(`íŒŒì¼ í¬ê¸°ê°€ 25MBë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. (${(audioBlob.size / 1024 / 1024).toFixed(2)}MB)\n\në¸Œë¼ìš°ì €ì—ì„œ íŒŒì¼ì„ ìë™ìœ¼ë¡œ ë¶„í• í•˜ì—¬ ì²˜ë¦¬í•©ë‹ˆë‹¤. ì´ ì‘ì—…ì€ ì‹œê°„ì´ ë§¤ìš° ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`);
                if (proceed) {
                    await processLargeAudio(audioBlob, fileName);
                } else {
                    statusEl.textContent = 'ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.';
                    fileUploader.value = '';
                }
            } else {
                await processSingleAudioChunk(audioBlob, fileName);
            }
        }
        
        async function processSingleAudioChunk(audioBlob, fileName) {
             try {
                statusEl.textContent = 'â³ Whisper AIê°€ ìŒì„±ì„ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜ ì¤‘...';
                const transcript = await transcribeWithWhisper(audioBlob, fileName);
                statusEl.textContent = 'â³ Gemini AIê°€ í…ìŠ¤íŠ¸ë¥¼ ìš”ì•½ ì¤‘...';
                const summary = await summarizeWithGemini(transcript);
                resultEl.innerText = summary;
                resultContainerEl.classList.remove('hidden');
                statusEl.textContent = 'âœ… ìš”ì•½ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!';
            } catch (error) {
                statusEl.textContent = `âŒ ì˜¤ë¥˜: ${error.message}`;
            }
        }

        // --- ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ---
        async function processLargeAudio(audioBlob, fileName) {
            try {
                statusEl.textContent = 'â³ ëŒ€ìš©ëŸ‰ ì˜¤ë””ì˜¤ íŒŒì¼ì„ ë””ì½”ë”© ì¤‘...';
                const audioContext = new AudioContext();
                const audioBuffer = await audioContext.decodeAudioData(await audioBlob.arrayBuffer());

                const MAX_CHUNK_SIZE_MB = 24;
                const MAX_CHUNK_SIZE_BYTES = MAX_CHUNK_SIZE_MB * 1024 * 1024;
                
                const duration = audioBuffer.duration;
                const sampleRate = audioBuffer.sampleRate;
                const bytesPerSample = 2; // 16-bit PCM
                const totalBytes = duration * sampleRate * audioBuffer.numberOfChannels * bytesPerSample;

                const numChunks = Math.ceil(totalBytes / MAX_CHUNK_SIZE_BYTES);
                const chunkDuration = duration / numChunks;
                
                let fullTranscript = "";
                for (let i = 0; i < numChunks; i++) {
                    statusEl.textContent = `â³ ì˜¤ë””ì˜¤ íŒŒì¼ ë¶„í•  ë° ì²˜ë¦¬ ì¤‘... (${i + 1}/${numChunks})`;
                    const startOffset = Math.round(i * chunkDuration * sampleRate);
                    const endOffset = Math.round((i + 1) * chunkDuration * sampleRate);
                    const chunkLength = endOffset - startOffset;

                    const chunkBuffer = audioContext.createBuffer(
                        audioBuffer.numberOfChannels,
                        chunkLength,
                        sampleRate
                    );

                    for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                        const channelData = audioBuffer.getChannelData(channel);
                        chunkBuffer.copyToChannel(channelData.subarray(startOffset, endOffset), channel);
                    }
                    
                    const chunkWavBlob = audioBufferToWav(chunkBuffer);
                    const chunkTranscript = await transcribeWithWhisper(chunkWavBlob, `chunk_${i}.wav`);
                    fullTranscript += chunkTranscript + " ";
                }
                
                statusEl.textContent = 'â³ Gemini AIê°€ ì „ì²´ í…ìŠ¤íŠ¸ë¥¼ ìš”ì•½ ì¤‘...';
                const summary = await summarizeWithGemini(fullTranscript);

                resultEl.innerText = summary;
                resultContainerEl.classList.remove('hidden');
                statusEl.textContent = 'âœ… ëŒ€ìš©ëŸ‰ íŒŒì¼ ìš”ì•½ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!';
            } catch (error) {
                 statusEl.textContent = `âŒ ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜: ${error.message}`;
            }
        }

        async function transcribeWithWhisper(audioBlob, fileName) {
            const formData = new FormData();
            formData.append('file', audioBlob, fileName);
            formData.append('model', 'whisper-1');
            const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${openaiKeyEl.value}` },
                body: formData
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error?.message || 'Whisper API í˜¸ì¶œ ì‹¤íŒ¨');
            return data.text;
        }

        async function summarizeWithGemini(transcript) {
            const prompt = `ë‹¤ìŒ íšŒì˜ë¡ í…ìŠ¤íŠ¸ë¥¼ ì•„ë˜ í˜•ì‹ì— ë§ì¶° Markdown ì–‘ì‹ìœ¼ë¡œ ë©‹ì§€ê²Œ ìš”ì•½í•´ ì£¼ì„¸ìš”.\n\n[íšŒì˜ë¡ í…ìŠ¤íŠ¸]\n${transcript}\n\n[ìš”ì•½ í˜•ì‹]\n### ğŸ“Œ í•µì‹¬ ìš”ì•½\n\n### ğŸ“ ìƒì„¸ ë‚´ìš©\n- \n\n### ğŸš€ Action Items\n- `;
            const body = { contents: [{ parts: [{ text: prompt }] }] };
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${googleKeyEl.value}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error?.message || 'Gemini API í˜¸ì¶œ ì‹¤íŒ¨');
            return data.candidates[0].content.parts[0].text;
        }

        // --- ë¶€ê°€ ê¸°ëŠ¥ ---
        function checkApiKeys() { /* ... */ }
        function startTimer() { /* ... */ }
        function stopTimer() { /* ... */ }
        copyBtn.addEventListener('click', () => { /* ... */ });
        shareBtn.addEventListener('click', () => { /* ... */ });
        
        // AudioBufferë¥¼ WAV Blobìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
        function audioBufferToWav(buffer) { /* ... */ }

    </script>
</body>
</html>

