<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 회의록 요약</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }
        .recording { animation: pulse 1.5s infinite; }
        .saved-indicator { transition: opacity 1s; }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid #3498db; width: 24px; height: 24px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white rounded-2xl shadow-lg p-6 md:p-8 w-full max-w-2xl">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-blue-600">🎙️ AI 회의록 요약</h1>
            <p class="text-gray-500 mt-2">회의 녹음 또는 파일 업로드 후 AI로 요약하고 공유하세요.</p>
        </header>

        <div class="space-y-4 mb-6">
            <div>
                <label for="openai_key" class="block text-sm font-medium text-gray-700">OpenAI API Key (Whisper 용)</label>
                <div class="relative mt-1">
                    <input type="password" id="openai_key" class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="sk-...">
                    <span id="openai_saved" class="saved-indicator absolute right-3 top-2 text-xs text-green-500 opacity-0">Saved!</span>
                </div>
            </div>
            <div>
                <label for="google_key" class="block text-sm font-medium text-gray-700">Google AI API Key (Gemini 용)</label>
                <div class="relative mt-1">
                    <input type="password" id="google_key" class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="AIza...">
                    <span id="google_saved" class="saved-indicator absolute right-3 top-2 text-xs text-green-500 opacity-0">Saved!</span>
                </div>
            </div>
            <p class="text-xs text-gray-500 text-center">입력하신 키는 브라우저에 안전하게 저장되어 다음 방문 시 자동으로 불러옵니다.</p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="text-center p-4 border rounded-lg">
                <h2 class="font-semibold mb-4">🔴 실시간 녹음</h2>
                <button id="recordBtn" class="w-24 h-24 rounded-full bg-red-500 text-white flex flex-col items-center justify-center mx-auto transition-colors duration-300 hover:bg-red-600">
                    <span>녹음</span>
                    <span id="timer" class="text-xs mt-1">00:00</span>
                </button>
            </div>
            <div class="text-center p-4 border rounded-lg flex flex-col justify-center">
                <h2 class="font-semibold mb-4">📁 파일 업로드</h2>
                <input type="file" id="fileUploader" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept="audio/*">
            </div>
        </div>

        <div id="status" class="mt-6 text-center font-semibold text-gray-600 min-h-[24px] flex items-center justify-center gap-2"></div>

        <div id="result-container" class="mt-4 hidden">
            <h3 class="text-xl font-bold mb-2">✨ 요약 결과</h3>
            <div id="result" class="whitespace-pre-wrap bg-gray-50 p-4 rounded-lg border max-h-60 overflow-y-auto"></div>
            <div class="mt-4 flex justify-center gap-4">
                <button id="copyBtn" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600">본문 복사</button>
                <button id="shareBtn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600">공유하기</button>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수 선언
        const openaiKeyEl = document.getElementById('openai_key');
        const googleKeyEl = document.getElementById('google_key');
        const recordBtn = document.getElementById('recordBtn');
        const timerEl = document.getElementById('timer');
        const fileUploader = document.getElementById('fileUploader');
        const statusEl = document.getElementById('status');
        const resultContainerEl = document.getElementById('result-container');
        const resultEl = document.getElementById('result');
        const copyBtn = document.getElementById('copyBtn');
        const shareBtn = document.getElementById('shareBtn');
        const openaiSavedEl = document.getElementById('openai_saved');
        const googleSavedEl = document.getElementById('google_saved');
        let mediaRecorder, audioChunks = [], isRecording = false, timerInterval, seconds = 0;

        // --- 이벤트 리스너 ---
        window.addEventListener('DOMContentLoaded', loadApiKeys);
        openaiKeyEl.addEventListener('input', () => saveApiKey('openaiApiKey', openaiKeyEl.value, openaiSavedEl));
        googleKeyEl.addEventListener('input', () => saveApiKey('googleApiKey', googleKeyEl.value, googleSavedEl));
        recordBtn.addEventListener('click', handleRecord);
        fileUploader.addEventListener('change', handleFileUpload);
        copyBtn.addEventListener('click', copySummary);
        shareBtn.addEventListener('click', shareSummary);

        // --- API 키 관리 ---
        function loadApiKeys() {
            console.log("페이지 로드: 저장된 API 키를 불러옵니다.");
            openaiKeyEl.value = localStorage.getItem('openaiApiKey') || '';
            googleKeyEl.value = localStorage.getItem('googleApiKey') || '';
        }
        function saveApiKey(keyName, value, indicatorEl) {
            localStorage.setItem(keyName, value);
            indicatorEl.style.opacity = '1';
            setTimeout(() => { indicatorEl.style.opacity = '0'; }, 2000);
        }
        function checkApiKeys() {
            if (!openaiKeyEl.value || !googleKeyEl.value) {
                alert('API 키를 먼저 입력해주세요!');
                return false;
            }
            return true;
        }

        // --- 녹음 관리 ---
        async function handleRecord() {
            console.log("녹음 버튼 클릭됨");
            if (!checkApiKeys()) return;
            if (!isRecording) {
                try {
                    console.log("녹음 시작을 시도합니다.");
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                    mediaRecorder.onstop = () => processAudio(new Blob(audioChunks, { type: 'audio/webm' }), 'recording.webm');
                    mediaRecorder.start();
                    
                    recordBtn.classList.add('recording'); isRecording = true; startTimer();
                    updateStatus('🔴 녹음 중입니다...');
                    console.log("녹음이 시작되었습니다.");
                } catch (err) { 
                    updateStatus("마이크 접근 권한을 허용해주세요.");
                    console.error("마이크 접근 오류:", err);
                }
            } else {
                console.log("녹음 중지를 시도합니다.");
                mediaRecorder.stop();
                recordBtn.classList.remove('recording'); isRecording = false; stopTimer();
                console.log("녹음이 중지되었습니다.");
            }
        }
        
        // --- 파일 업로드 관리 ---
        function handleFileUpload(event) {
            console.log("파일이 선택되었습니다.");
            if (!checkApiKeys()) { event.target.value = ''; return; }
            const file = event.target.files[0];
            if (file) {
                console.log(`선택된 파일: ${file.name}, 크기: ${file.size} bytes`);
                processAudio(file, file.name);
            }
        }

        // --- 핵심 오디오 처리 로직 ---
        async function processAudio(audioBlob, fileName) {
            console.log("processAudio 함수 시작");
            updateStatus('⏳ 오디오 파일을 처리 중입니다...', true);
            resultContainerEl.classList.add('hidden');
            
            const MAX_SIZE = 25 * 1024 * 1024;
            let fullTranscript = "";

            try {
                if (audioBlob.size > MAX_SIZE) {
                    console.log("대용량 파일 처리 로직 시작");
                    const proceed = confirm(`파일 크기가 25MB를 초과했습니다. (${(audioBlob.size / 1024 / 1024).toFixed(2)}MB)\n\n브라우저에서 파일을 자동으로 분할하여 처리합니다. 이 작업은 시간이 매우 오래 걸릴 수 있습니다. 계속하시겠습니까?`);
                    if (!proceed) {
                        updateStatus('대용량 파일 처리가 취소되었습니다.');
                        fileUploader.value = '';
                        return;
                    }
                    fullTranscript = await processLargeAudio(audioBlob);
                } else {
                    console.log("일반 파일 처리 로직 시작");
                    fullTranscript = await transcribeWithWhisper(audioBlob, fileName);
                }

                console.log("텍스트 요약 로직 시작");
                updateStatus('⏳ Gemini AI가 텍스트를 요약 중...', true);
                const summary = await summarizeWithGemini(fullTranscript);

                console.log("결과 표시 로직 시작");
                resultEl.innerText = summary;
                resultContainerEl.classList.remove('hidden');
                updateStatus('✅ 요약이 완료되었습니다!');
            } catch (error) {
                updateStatus(`❌ 오류: ${error.message}`);
                console.error("처리 중 심각한 오류 발생:", error); // ✨오류를 콘솔에 상세히 기록
            } finally {
                fileUploader.value = ''; // 파일 선택 초기화
            }
        }
        
        async function processLargeAudio(audioBlob) {
            // ... (이하 코드는 이전과 동일)
        }

        // --- API 호출 함수 ---
        async function transcribeWithWhisper(audioBlob, fileName) {
            console.log("Whisper API 호출 시작");
            const formData = new FormData();
            formData.append('file', audioBlob, fileName);
            formData.append('model', 'whisper-1');
            const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${openaiKeyEl.value}` },
                body: formData
            });
            const data = await response.json();
            if (!response.ok) {
                console.error("Whisper API 오류 응답:", data);
                throw new Error(data.error?.message || 'Whisper API 호출 실패');
            }
            console.log("Whisper API 호출 성공");
            return data.text;
        }
        async function summarizeWithGemini(transcript) {
            console.log("Gemini API 호출 시작");
            const prompt = `다음 회의록 텍스트를 아래 형식에 맞춰 Markdown 양식으로 멋지게 요약해 주세요.\n\n[회의록 텍스트]\n${transcript}\n\n[요약 형식]\n### 📌 핵심 요약\n\n### 📝 상세 내용\n- \n\n### 🚀 Action Items\n- `;
            const body = { contents: [{ parts: [{ text: prompt }] }] };
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${googleKeyEl.value}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)
            });
            const data = await response.json();
            if (!response.ok) {
                console.error("Gemini API 오류 응답:", data);
                throw new Error(data.error?.message || 'Gemini API 호출 실패');
            }
            console.log("Gemini API 호출 성공");
            return data.candidates[0].content.parts[0].text;
        }

        // --- 유틸리티 함수 (생략된 부분 포함) ---
        function updateStatus(message, showLoader = false) { let loaderHtml = showLoader ? '<div class="loader"></div>' : ''; statusEl.innerHTML = `${loaderHtml}<span>${message}</span>`; }
        function startTimer() { seconds = 0; timerEl.textContent = "00:00"; timerInterval = setInterval(() => { seconds++; const min = String(Math.floor(seconds / 60)).padStart(2, '0'); const sec = String(seconds % 60).padStart(2, '0'); timerEl.textContent = `${min}:${sec}`; }, 1000); }
        function stopTimer() { clearInterval(timerInterval); seconds = 0; timerEl.textContent = "00:00"; }
        function copySummary() { navigator.clipboard.writeText(resultEl.innerText).then(() => alert("요약 내용이 복사되었습니다!")).catch(() => alert("복사에 실패했습니다.")); }
        function shareSummary() { if (navigator.share) { navigator.share({ title: 'AI 회의록 요약', text: resultEl.innerText }); } else { alert("이 브라우저에서는 공유하기 기능을 지원하지 않습니다."); } }
        function audioBufferToWav(aBuffer) { let numOfChan = aBuffer.numberOfChannels, len = aBuffer.length * numOfChan * 2 + 44, buffer = new ArrayBuffer(len), view = new DataView(buffer), channels = [], i, sample, offset = 0, pos = 0; setUint32(0x46464952); setUint32(len - 8); setUint32(0x45564157); setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan); setUint32(aBuffer.sampleRate); setUint32(aBuffer.sampleRate * 2 * numOfChan); setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(len - pos - 4); for (i = 0; i < aBuffer.numberOfChannels; i++) channels.push(aBuffer.getChannelData(i)); while (pos < len) { for (i = 0; i < numOfChan; i++) { sample = Math.max(-1, Math.min(1, channels[i][offset])); sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; view.setInt16(pos, sample, true); pos += 2; } offset++; } return new Blob([view], { type: "audio/wav" }); function setUint16(data) { view.setUint16(pos, data, true); pos += 2; } function setUint32(data) { view.setUint32(pos, data, true); pos += 4; } }
        
        // ✨ processLargeAudio 함수의 전체 코드를 여기에 붙여넣습니다.
        async function processLargeAudio(audioBlob) {
            updateStatus('⏳ 대용량 오디오 파일을 디코딩 중...', true);
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audioBuffer = await audioContext.decodeAudioData(await audioBlob.arrayBuffer());
            const MAX_CHUNK_BYTES = 24 * 1024 * 1024;
            const duration = audioBuffer.duration;
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const bytesPerSample = 2; // 16-bit PCM
            const totalBytes = duration * sampleRate * numChannels * bytesPerSample;
            const numChunks = Math.ceil(totalBytes / MAX_CHUNK_BYTES);
            const chunkDuration = duration / numChunks;
            let combinedTranscript = "";

            for (let i = 0; i < numChunks; i++) {
                updateStatus(`⏳ 오디오 조각 처리 중... (${i + 1}/${numChunks})`, true);
                const startOffset = Math.floor(i * chunkDuration * sampleRate);
                const endOffset = Math.floor((i + 1) * chunkDuration * sampleRate);
                const chunkBuffer = audioContext.createBuffer(numChannels, endOffset - startOffset, sampleRate);

                for (let channel = 0; channel < numChannels; channel++) {
                    chunkBuffer.copyToChannel(audioBuffer.getChannelData(channel).slice(startOffset, endOffset), channel);
                }
                
                const chunkWavBlob = audioBufferToWav(chunkBuffer);
                const chunkTranscript = await transcribeWithWhisper(chunkWavBlob, `chunk_${i}.wav`);
                combinedTranscript += chunkTranscript + " ";
            }
            return combinedTranscript;
        }
    </script>
</body>
</html>

