<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI íšŒì˜ë¡ ìš”ì•½ - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @keyframes pulse { 
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 
            70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); } 
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } 
        }
        .recording { animation: pulse 1.5s infinite; }
        .saved-indicator { transition: opacity 1s; }
        .loader { 
            border: 4px solid #f3f3f3; 
            border-radius: 50%; 
            border-top: 4px solid #3498db; 
            width: 24px; 
            height: 24px; 
            animation: spin 2s linear infinite; 
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
        .history-item:hover {
            background-color: #f3f4f6;
        }
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white rounded-2xl shadow-lg p-6 md:p-8 w-full max-w-4xl">
        <!-- í—¤ë” -->
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-blue-600">ğŸ™ï¸ AI íšŒì˜ë¡ ìš”ì•½</h1>
            <p class="text-gray-500 mt-2">íšŒì˜ ë…¹ìŒ ë˜ëŠ” íŒŒì¼ ì—…ë¡œë“œ í›„ AIë¡œ ìš”ì•½í•˜ê³  ê³µìœ í•˜ì„¸ìš”.</p>
            <!-- ë„¤íŠ¸ì›Œí¬ ìƒíƒœ í‘œì‹œ -->
            <div id="networkStatus" class="mt-2 text-sm"></div>
        </header>

        <!-- API í‚¤ ì…ë ¥ ì„¹ì…˜ -->
        <div class="space-y-4 mb-6 bg-blue-50 p-4 rounded-lg">
            <div>
                <label for="openai_key" class="block text-sm font-medium text-gray-700">
                    OpenAI API Key (Whisper ìš©)
                    <a href="https://platform.openai.com/api-keys" target="_blank" class="text-blue-500 text-xs ml-2">í‚¤ ë°œê¸‰ë°›ê¸° â†’</a>
                </label>
                <div class="relative mt-1">
                    <input 
                        type="password" 
                        id="openai_key" 
                        class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500" 
                        placeholder="sk-..."
                        aria-label="OpenAI API í‚¤ ì…ë ¥">
                    <button 
                        id="toggleOpenAI" 
                        class="absolute right-10 top-2 text-gray-500 hover:text-gray-700"
                        aria-label="API í‚¤ í‘œì‹œ/ìˆ¨ê¸°ê¸°">
                        ğŸ‘ï¸
                    </button>
                    <span id="openai_saved" class="saved-indicator absolute right-3 top-2 text-xs text-green-500 opacity-0">Saved!</span>
                </div>
            </div>
            <div>
                <label for="google_key" class="block text-sm font-medium text-gray-700">
                    Google AI API Key (Gemini ìš©)
                    <a href="https://makersuite.google.com/app/apikey" target="_blank" class="text-blue-500 text-xs ml-2">í‚¤ ë°œê¸‰ë°›ê¸° â†’</a>
                </label>
                <div class="relative mt-1">
                    <input 
                        type="password" 
                        id="google_key" 
                        class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500" 
                        placeholder="AIza..."
                        aria-label="Google AI API í‚¤ ì…ë ¥">
                    <button 
                        id="toggleGoogle" 
                        class="absolute right-10 top-2 text-gray-500 hover:text-gray-700"
                        aria-label="API í‚¤ í‘œì‹œ/ìˆ¨ê¸°ê¸°">
                        ğŸ‘ï¸
                    </button>
                    <span id="google_saved" class="saved-indicator absolute right-3 top-2 text-xs text-green-500 opacity-0">Saved!</span>
                </div>
            </div>
            <p class="text-xs text-gray-600 text-center bg-yellow-50 p-2 rounded">
                âš ï¸ API í‚¤ëŠ” ë¸Œë¼ìš°ì €ì— ë¡œì»¬ ì €ì¥ë©ë‹ˆë‹¤. GitHub PagesëŠ” ì„œë²„ê°€ ì—†ì–´ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì§ì ‘ APIë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.<br>
                í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” ë°˜ë“œì‹œ ë°±ì—”ë“œ ì„œë²„ë¥¼ í†µí•´ APIë¥¼ í˜¸ì¶œí•˜ì„¸ìš”.
            </p>
        </div>

        <!-- ë©”ì¸ ê¸°ëŠ¥ ì„¹ì…˜ -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- ì‹¤ì‹œê°„ ë…¹ìŒ -->
            <div class="text-center p-4 border rounded-lg">
                <h2 class="font-semibold mb-4">ğŸ”´ ì‹¤ì‹œê°„ ë…¹ìŒ</h2>
                <button 
                    id="recordBtn" 
                    class="w-24 h-24 rounded-full bg-red-500 text-white flex flex-col items-center justify-center mx-auto transition-colors duration-300 hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300"
                    aria-label="ë…¹ìŒ ì‹œì‘/ì¤‘ì§€"
                    aria-pressed="false">
                    <span aria-live="polite">ë…¹ìŒ</span>
                    <span id="timer" class="text-xs mt-1">00:00</span>
                </button>
                <!-- ì˜¤ë””ì˜¤ í’ˆì§ˆ ì„¤ì • -->
                <div class="mt-4">
                    <label class="text-xs text-gray-600">
                        <input type="checkbox" id="highQuality" checked> ê³ í’ˆì§ˆ ë…¹ìŒ
                    </label>
                </div>
            </div>
            
            <!-- íŒŒì¼ ì—…ë¡œë“œ -->
            <div class="text-center p-4 border rounded-lg flex flex-col justify-center">
                <h2 class="font-semibold mb-4">ğŸ“ íŒŒì¼ ì—…ë¡œë“œ</h2>
                <input 
                    type="file" 
                    id="fileUploader" 
                    class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" 
                    accept="audio/*,video/*,.m4a,.mp3,.wav,.webm,.mp4,.mpeg,.mpga,.ogg,.oga,.flac"
                    aria-label="ì˜¤ë””ì˜¤ íŒŒì¼ ì„ íƒ">
                <p class="text-xs text-gray-500 mt-2">ì§€ì›: MP3, M4A, WAV, WebM, MP4, OGG, FLAC (ìµœëŒ€ 25MB)</p>
            </div>
        </div>

        <!-- ê³ ê¸‰ ì„¤ì • -->
        <details class="mt-4 bg-gray-50 p-4 rounded-lg">
            <summary class="cursor-pointer font-semibold text-gray-700">âš™ï¸ ê³ ê¸‰ ì„¤ì •</summary>
            <div class="mt-4 space-y-3">
                <div>
                    <label for="language" class="block text-sm font-medium text-gray-700">ì „ì‚¬ ì–¸ì–´</label>
                    <select id="language" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
                        <option value="ko">í•œêµ­ì–´</option>
                        <option value="en">ì˜ì–´</option>
                        <option value="ja">ì¼ë³¸ì–´</option>
                        <option value="zh">ì¤‘êµ­ì–´</option>
                        <option value="auto">ìë™ ê°ì§€</option>
                    </select>
                </div>
                <div>
                    <label for="summaryStyle" class="block text-sm font-medium text-gray-700">ìš”ì•½ ìŠ¤íƒ€ì¼</label>
                    <select id="summaryStyle" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
                        <option value="default">ê¸°ë³¸ (í•µì‹¬ìš”ì•½ + ìƒì„¸ë‚´ìš© + Action Items)</option>
                        <option value="brief">ê°„ëµ (í•µì‹¬ë§Œ)</option>
                        <option value="detailed">ìƒì„¸ (ëª¨ë“  ë‚´ìš© í¬í•¨)</option>
                        <option value="minutes">íšŒì˜ë¡ í˜•ì‹</option>
                    </select>
                </div>
                <div>
                    <label for="customPrompt" class="block text-sm font-medium text-gray-700">ì»¤ìŠ¤í…€ í”„ë¡¬í”„íŠ¸ (ì„ íƒì‚¬í•­)</label>
                    <textarea 
                        id="customPrompt" 
                        rows="3" 
                        class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
                        placeholder="ì˜ˆ: ê¸°ìˆ ì ì¸ ë‚´ìš© ìœ„ì£¼ë¡œ ìš”ì•½í•´ì£¼ì„¸ìš”..."></textarea>
                </div>
            </div>
        </details>

        <!-- ìƒíƒœ í‘œì‹œ -->
        <div id="status" class="mt-6 text-center font-semibold text-gray-600 min-h-[24px] flex items-center justify-center gap-2"></div>
        
        <!-- ì§„í–‰ë¥  í‘œì‹œ -->
        <div id="progressContainer" class="hidden mt-2">
            <div class="w-full bg-gray-200 rounded-full h-2.5">
                <div id="progressBar" class="progress-bar bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="progressText" class="text-xs text-gray-500 mt-1 text-center"></p>
        </div>

        <!-- ê²°ê³¼ ì»¨í…Œì´ë„ˆ -->
        <div id="result-container" class="mt-4 hidden">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xl font-bold">âœ¨ ìš”ì•½ ê²°ê³¼</h3>
                <button id="saveToHistory" class="text-sm bg-gray-200 px-3 py-1 rounded hover:bg-gray-300">
                    ğŸ“‹ íˆìŠ¤í† ë¦¬ì— ì €ì¥
                </button>
            </div>
            <div id="result" class="whitespace-pre-wrap bg-gray-50 p-4 rounded-lg border max-h-96 overflow-y-auto"></div>
            
            <!-- ì•¡ì…˜ ë²„íŠ¼ë“¤ -->
            <div class="mt-4 flex flex-wrap justify-center gap-3">
                <button id="copyBtn" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition">
                    ğŸ“‹ ë³µì‚¬
                </button>
                <button id="copyMarkdownBtn" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition">
                    ğŸ“ Markdown ë³µì‚¬
                </button>
                <button id="shareBtn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition">
                    ğŸ”— ê³µìœ 
                </button>
                <button id="pdfBtn" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition">
                    ğŸ“„ PDF
                </button>
                <button id="retryBtn" class="bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600 transition">
                    ğŸ”„ ë‹¤ì‹œ ìš”ì•½
                </button>
            </div>
        </div>

        <!-- íˆìŠ¤í† ë¦¬ ì„¹ì…˜ -->
        <details id="historySection" class="mt-6 bg-gray-50 p-4 rounded-lg">
            <summary class="cursor-pointer font-semibold text-gray-700">ğŸ“š ìµœê·¼ ìš”ì•½ íˆìŠ¤í† ë¦¬</summary>
            <div id="historyList" class="mt-4 space-y-2 max-h-60 overflow-y-auto"></div>
            <button id="clearHistory" class="mt-2 text-xs text-red-500 hover:text-red-700">íˆìŠ¤í† ë¦¬ ëª¨ë‘ ì‚­ì œ</button>
        </details>
    </div>

    <script>
        // ========== ì „ì—­ ë³€ìˆ˜ ==========
        const elements = {
            openaiKey: document.getElementById('openai_key'),
            googleKey: document.getElementById('google_key'),
            recordBtn: document.getElementById('recordBtn'),
            timer: document.getElementById('timer'),
            fileUploader: document.getElementById('fileUploader'),
            status: document.getElementById('status'),
            resultContainer: document.getElementById('result-container'),
            result: document.getElementById('result'),
            progressContainer: document.getElementById('progressContainer'),
            progressBar: document.getElementById('progressBar'),
            progressText: document.getElementById('progressText'),
            networkStatus: document.getElementById('networkStatus'),
            language: document.getElementById('language'),
            summaryStyle: document.getElementById('summaryStyle'),
            customPrompt: document.getElementById('customPrompt'),
            highQuality: document.getElementById('highQuality'),
            historyList: document.getElementById('historyList'),
            historySection: document.getElementById('historySection')
        };

        let mediaRecorder, audioChunks = [], isRecording = false, timerInterval, seconds = 0;
        let currentFileName = '', currentTranscript = '', retryCount = 0;
        const MAX_RETRIES = 3;

        // ========== ì´ˆê¸°í™” ë° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ==========
        window.addEventListener('DOMContentLoaded', init);

        function init() {
            loadApiKeys();
            loadHistory();
            updateNetworkStatus();
            setupEventListeners();
            checkBrowserCompatibility();
        }

        function setupEventListeners() {
            // API í‚¤ ê´€ë ¨
            elements.openaiKey.addEventListener('input', () => saveApiKey('openaiApiKey', elements.openaiKey.value, document.getElementById('openai_saved')));
            elements.googleKey.addEventListener('input', () => saveApiKey('googleApiKey', elements.googleKey.value, document.getElementById('google_saved')));
            
            // í† ê¸€ ë²„íŠ¼
            document.getElementById('toggleOpenAI').addEventListener('click', () => togglePasswordVisibility('openai_key'));
            document.getElementById('toggleGoogle').addEventListener('click', () => togglePasswordVisibility('google_key'));
            
            // ë©”ì¸ ê¸°ëŠ¥
            elements.recordBtn.addEventListener('click', handleRecord);
            elements.recordBtn.addEventListener('keydown', handleKeyPress);
            elements.fileUploader.addEventListener('change', handleFileUpload);
            
            // ê²°ê³¼ ì•¡ì…˜
            document.getElementById('copyBtn')?.addEventListener('click', () => copyToClipboard(elements.result.innerText, 'ìš”ì•½'));
            document.getElementById('copyMarkdownBtn')?.addEventListener('click', () => copyToClipboard(elements.result.innerText, 'Markdown'));
            document.getElementById('shareBtn')?.addEventListener('click', shareSummary);
            document.getElementById('pdfBtn')?.addEventListener('click', downloadPdf);
            document.getElementById('retryBtn')?.addEventListener('click', retrySummary);
            document.getElementById('saveToHistory')?.addEventListener('click', () => saveToHistory(elements.result.innerText));
            
            // íˆìŠ¤í† ë¦¬
            document.getElementById('clearHistory')?.addEventListener('click', clearHistory);
            
            // ë„¤íŠ¸ì›Œí¬ ìƒíƒœ
            window.addEventListener('online', updateNetworkStatus);
            window.addEventListener('offline', updateNetworkStatus);
        }

        // ========== ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬ ==========
        function checkBrowserCompatibility() {
            const warnings = [];
            if (!navigator.mediaDevices?.getUserMedia) {
                warnings.push('ë§ˆì´í¬ ë…¹ìŒ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.');
            }
            if (!window.MediaRecorder) {
                warnings.push('MediaRecorder APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }
            if (warnings.length > 0) {
                updateStatus(`âš ï¸ ${warnings.join(' ')}`, false);
            }
        }

        // ========== API í‚¤ ê´€ë¦¬ ==========
        function loadApiKeys() {
            elements.openaiKey.value = localStorage.getItem('openaiApiKey') || '';
            elements.googleKey.value = localStorage.getItem('googleApiKey') || '';
        }

        function saveApiKey(keyName, value, indicatorEl) {
            try {
                localStorage.setItem(keyName, value);
                indicatorEl.style.opacity = '1';
                setTimeout(() => { indicatorEl.style.opacity = '0'; }, 2000);
            } catch (e) {
                console.error('localStorage ì €ì¥ ì‹¤íŒ¨:', e);
                alert('ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ localStorageë¥¼ í™œì„±í™”í•´ì£¼ì„¸ìš”.');
            }
        }

        function checkApiKeys() {
            if (!elements.openaiKey.value || !elements.googleKey.value) {
                alert('API í‚¤ë¥¼ ë¨¼ì € ì…ë ¥í•´ì£¼ì„¸ìš”!\n\n1. OpenAI: https://platform.openai.com/api-keys\n2. Google AI: https://makersuite.google.com/app/apikey');
                return false;
            }
            if (elements.openaiKey.value.length < 20 || !elements.openaiKey.value.startsWith('sk-')) {
                alert('ìœ íš¨í•œ OpenAI API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”. (sk-ë¡œ ì‹œì‘)');
                return false;
            }
            if (elements.googleKey.value.length < 20 || !elements.googleKey.value.startsWith('AIza')) {
                alert('ìœ íš¨í•œ Google AI API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”. (AIzaë¡œ ì‹œì‘)');
                return false;
            }
            return true;
        }

        function togglePasswordVisibility(inputId) {
            const input = document.getElementById(inputId);
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        // ========== ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ==========
        function updateNetworkStatus() {
            const online = navigator.onLine;
            elements.networkStatus.innerHTML = online 
                ? '<span class="text-green-500">ğŸŸ¢ ì˜¨ë¼ì¸</span>' 
                : '<span class="text-red-500">ğŸ”´ ì˜¤í”„ë¼ì¸ - ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•˜ì„¸ìš”</span>';
            
            if (!online) {
                updateStatus('âŒ ì¸í„°ë„· ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
            }
        }

        // ========== ë…¹ìŒ ê´€ë¦¬ ==========
        async function handleRecord() {
            if (!checkApiKeys()) return;
            if (!navigator.onLine) {
                alert('ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            try {
                const constraints = {
                    audio: elements.highQuality.checked ? {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100,
                        channelCount: 2
                    } : true
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // ë¸Œë¼ìš°ì €ë³„ ìµœì  MIME íƒ€ì… ì„ íƒ
                const mimeTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/ogg;codecs=opus',
                    'audio/mp4'
                ];
                
                let selectedMimeType = 'audio/webm';
                for (const mimeType of mimeTypes) {
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        selectedMimeType = mimeType;
                        break;
                    }
                }

                mediaRecorder = new MediaRecorder(stream, { mimeType: selectedMimeType });
                audioChunks = [];
                
                mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };
                
                mediaRecorder.onstop = () => {
                    currentFileName = `recording_${new Date().toISOString()}.webm`;
                    const audioBlob = new Blob(audioChunks, { type: selectedMimeType });
                    processAudio(audioBlob, currentFileName);
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start(1000); // 1ì´ˆë§ˆë‹¤ ë°ì´í„° ìˆ˜ì§‘
                elements.recordBtn.classList.add('recording');
                elements.recordBtn.setAttribute('aria-pressed', 'true');
                isRecording = true;
                startTimer();
                updateStatus('ğŸ”´ ë…¹ìŒ ì¤‘ì…ë‹ˆë‹¤... (ë‹¤ì‹œ í´ë¦­í•˜ë©´ ì¤‘ì§€)');
            } catch (err) {
                console.error('ë…¹ìŒ ì‹œì‘ ì‹¤íŒ¨:', err);
                updateStatus('âŒ ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                elements.recordBtn.classList.remove('recording');
                elements.recordBtn.setAttribute('aria-pressed', 'false');
                isRecording = false;
                stopTimer();
                updateStatus('â¹ï¸ ë…¹ìŒì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }

        function handleKeyPress(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleRecord();
            }
        }

        // ========== íŒŒì¼ ì—…ë¡œë“œ ê´€ë¦¬ ==========
        async function handleFileUpload(event) {
            if (!checkApiKeys()) {
                event.target.value = '';
                return;
            }
            
            const file = event.target.files[0];
            if (!file) return;

            // íŒŒì¼ í¬ê¸° ì²´í¬
            const MAX_SIZE = 25 * 1024 * 1024;
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            
            if (file.size > MAX_SIZE) {
                // 25MB ì´ˆê³¼ ì‹œ ìë™ ì²˜ë¦¬ ì•ˆë‚´
                const message = `ğŸ“¦ ëŒ€ìš©ëŸ‰ íŒŒì¼ ê°ì§€ (${sizeMB}MB)\n\nìë™ìœ¼ë¡œ ì••ì¶• ë° ë¶„í•  ì²˜ë¦¬ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤.\nì²˜ë¦¬ ì‹œê°„ì€ íŒŒì¼ í¬ê¸°ì— ë”°ë¼ ë‹¬ë¼ì§‘ë‹ˆë‹¤.\n\nì˜ˆìƒ ì‹œê°„:\n- 25-50MB: 2-5ë¶„\n- 50-100MB: 5-10ë¶„\n- 100MB+: 10ë¶„ ì´ìƒ\n\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                
                if (!confirm(message)) {
                    event.target.value = '';
                    return;
                }
                
                // í° íŒŒì¼ ì²˜ë¦¬ ì¤‘ ë¸Œë¼ìš°ì € ì¢…ë£Œ ê²½ê³ 
                window.onbeforeunload = function() {
                    return "íŒŒì¼ ì²˜ë¦¬ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ë– ë‚˜ì‹œê² ìŠµë‹ˆê¹Œ?";
                };
            }

            currentFileName = file.name;
            
            // M4A ë° ê¸°íƒ€ í˜•ì‹ ì²˜ë¦¬
            if (file.name.toLowerCase().endsWith('.m4a') || 
                file.type === 'audio/x-m4a' || 
                file.type === 'audio/mp4' ||
                file.type === 'audio/mpeg' ||
                file.type === 'video/mp4') {
                
                updateStatus(`â³ ${sizeMB}MB íŒŒì¼ ì²˜ë¦¬ ì¤‘...`, true);
                
                try {
                    await processAudio(file, currentFileName);
                } catch (error) {
                    console.error('íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨:', error);
                    updateStatus(`âŒ íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: ${error.message}`);
                } finally {
                    // ì²˜ë¦¬ ì™„ë£Œ í›„ ê²½ê³  ì œê±°
                    window.onbeforeunload = null;
                }
            } else {
                // ê¸°íƒ€ ì˜¤ë””ì˜¤ í˜•ì‹ ì§ì ‘ ì²˜ë¦¬
                await processAudio(file, currentFileName);
                window.onbeforeunload = null;
            }
        }

        // ========== ì˜¤ë””ì˜¤ ì²˜ë¦¬ ==========
        async function processAudio(audioBlob, fileName) {
            updateStatus('â³ ì˜¤ë””ì˜¤ íŒŒì¼ ì²˜ë¦¬ ì¤€ë¹„ ì¤‘...', true);
            showProgress(0, 'ì¤€ë¹„ ì¤‘...');
            elements.resultContainer.classList.add('hidden');
            retryCount = 0;

            try {
                const MAX_SIZE = 25 * 1024 * 1024; // 25MB
                let processedBlob = audioBlob;
                let fullTranscript = "";

                // íŒŒì¼ í¬ê¸° ì²´í¬ ë° ì²˜ë¦¬
                if (audioBlob.size > MAX_SIZE) {
                    const sizeMB = (audioBlob.size / 1024 / 1024).toFixed(2);
                    updateStatus(`ğŸ“¦ ëŒ€ìš©ëŸ‰ íŒŒì¼ ê°ì§€ (${sizeMB}MB) - ìë™ ì²˜ë¦¬ ì¤‘...`, true);
                    
                    // ì••ì¶• ì‹œë„
                    updateStatus('ğŸ”„ ì˜¤ë””ì˜¤ ì••ì¶• ì‹œë„ ì¤‘...', true);
                    showProgress(10, 'ì••ì¶• ì¤‘...');
                    processedBlob = await compressAudio(audioBlob, fileName);
                    
                    const compressedSizeMB = (processedBlob.size / 1024 / 1024).toFixed(2);
                    updateStatus(`âœ… ì••ì¶• ì™„ë£Œ: ${sizeMB}MB â†’ ${compressedSizeMB}MB`, true);
                    
                    // ì••ì¶• í›„ì—ë„ 25MB ì´ˆê³¼ ì‹œ ì²­í‚¹
                    if (processedBlob.size > MAX_SIZE) {
                        updateStatus('ğŸ“‚ íŒŒì¼ ë¶„í•  ì²˜ë¦¬ ì¤‘... (ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤)', true);
                        fullTranscript = await processLargeAudioInChunks(processedBlob, fileName);
                    } else {
                        // ì••ì¶• ì„±ê³µ, ë‹¨ì¼ ì²˜ë¦¬
                        showProgress(30, 'ìŒì„± ì¸ì‹ ì¤‘...');
                        fullTranscript = await transcribeWithWhisper(processedBlob, fileName);
                    }
                } else {
                    // 25MB ì´í•˜, ì§ì ‘ ì²˜ë¦¬
                    showProgress(30, 'ìŒì„± ì¸ì‹ ì¤‘...');
                    fullTranscript = await transcribeWithWhisper(audioBlob, fileName);
                }

                currentTranscript = fullTranscript;
                
                if (!currentTranscript || currentTranscript.trim().length === 0) {
                    throw new Error('ìŒì„± ì¸ì‹ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ì˜¤ë””ì˜¤ íŒŒì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }

                // ìš”ì•½
                updateStatus('â³ Gemini AIê°€ í…ìŠ¤íŠ¸ë¥¼ ìš”ì•½ ì¤‘...', true);
                showProgress(70, 'ìš”ì•½ ìƒì„± ì¤‘...');
                const summary = await summarizeWithGemini(currentTranscript);

                // ê²°ê³¼ í‘œì‹œ
                showProgress(100, 'ì™„ë£Œ!');
                elements.result.innerText = summary;
                elements.resultContainer.classList.remove('hidden');
                updateStatus('âœ… ìš”ì•½ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!');
                hideProgress();

                // ìë™ ì €ì¥ ì˜µì…˜
                if (confirm('ìš”ì•½ ê²°ê³¼ë¥¼ íˆìŠ¤í† ë¦¬ì— ìë™ ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    saveToHistory(summary);
                }

            } catch (error) {
                console.error('ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                handleProcessingError(error);
            } finally {
                elements.fileUploader.value = '';
            }
        }

        // ========== ì˜¤ë””ì˜¤ ì••ì¶• ==========
        async function compressAudio(audioBlob, fileName) {
            try {
                updateStatus('ğŸµ ì˜¤ë””ì˜¤ ë””ì½”ë”© ì¤‘...', true);
                
                // AudioContextë¡œ ë””ì½”ë”©
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // ì••ì¶• ì„¤ì • ê³„ì‚°
                const originalSampleRate = audioBuffer.sampleRate;
                const targetSampleRate = 16000; // Whisper API ìµœì  ìƒ˜í”Œë ˆì´íŠ¸
                const channels = 1; // ëª¨ë…¸ë¡œ ë³€í™˜
                
                // ë‹¤ìš´ìƒ˜í”Œë§ ë° ëª¨ë…¸ ë³€í™˜
                const offlineContext = new OfflineAudioContext(
                    channels, 
                    Math.floor(audioBuffer.duration * targetSampleRate),
                    targetSampleRate
                );
                
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                
                // ì••ì¶• (ë‹¤ì´ë‚˜ë¯¹ ë ˆì¸ì§€ ì••ì¶•)
                const compressor = offlineContext.createDynamicsCompressor();
                compressor.threshold.value = -24;
                compressor.knee.value = 30;
                compressor.ratio.value = 12;
                compressor.attack.value = 0.003;
                compressor.release.value = 0.25;
                
                source.connect(compressor);
                compressor.connect(offlineContext.destination);
                source.start(0);
                
                const renderedBuffer = await offlineContext.startRendering();
                
                // WAVë¡œ ë³€í™˜ (ì••ì¶•ëœ í¬ë§·)
                const wavBlob = audioBufferToWav(renderedBuffer, targetSampleRate);
                
                // MP3ë¡œ ì¶”ê°€ ì••ì¶• ì‹œë„ (lamejs ì‚¬ìš©í•˜ì§€ ì•Šê³  WAV ìœ ì§€)
                // Whisper APIëŠ” WAVë¥¼ ì˜ ì²˜ë¦¬í•˜ë¯€ë¡œ WAV ìœ ì§€
                
                return wavBlob;
                
            } catch (error) {
                console.error('ì••ì¶• ì‹¤íŒ¨, ì›ë³¸ ì‚¬ìš©:', error);
                return audioBlob; // ì••ì¶• ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë°˜í™˜
            }
        }

        // ========== ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²­í‚¹ ì²˜ë¦¬ ==========
        async function processLargeAudioInChunks(audioBlob, fileName) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                const duration = audioBuffer.duration;
                const sampleRate = audioBuffer.sampleRate;
                const numChannels = audioBuffer.numberOfChannels;
                
                // ì²­í¬ ì„¤ì • (5ë¶„ ë‹¨ìœ„ë¡œ ë¶„í• , ìµœëŒ€ 24MB)
                const chunkDuration = Math.min(300, duration); // 5ë¶„ ë˜ëŠ” ì „ì²´ ê¸¸ì´
                const MAX_CHUNK_SIZE = 24 * 1024 * 1024; // 24MB (ì•ˆì „ ë§ˆì§„)
                
                // ì²­í¬ í¬ê¸° ê³„ì‚°
                const bytesPerSecond = sampleRate * numChannels * 2; // 16-bit = 2 bytes
                const optimalChunkDuration = Math.min(
                    chunkDuration,
                    MAX_CHUNK_SIZE / bytesPerSecond
                );
                
                const numChunks = Math.ceil(duration / optimalChunkDuration);
                let combinedTranscript = "";
                
                updateStatus(`ğŸ”ª ì˜¤ë””ì˜¤ë¥¼ ${numChunks}ê°œ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬í•©ë‹ˆë‹¤...`, true);
                
                for (let i = 0; i < numChunks; i++) {
                    const startTime = i * optimalChunkDuration;
                    const endTime = Math.min((i + 1) * optimalChunkDuration, duration);
                    const chunkProgress = 30 + (40 * (i / numChunks)); // 30-70% êµ¬ê°„
                    
                    showProgress(chunkProgress, `ì²­í¬ ${i + 1}/${numChunks} ì²˜ë¦¬ ì¤‘...`);
                    updateStatus(`ğŸ“ íŒŒíŠ¸ ${i + 1}/${numChunks} ì „ì‚¬ ì¤‘... (${formatTime(startTime)} - ${formatTime(endTime)})`, true);
                    
                    // ì²­í¬ ì¶”ì¶œ
                    const chunkBuffer = extractAudioChunk(audioBuffer, startTime, endTime, sampleRate);
                    
                    // ì²­í¬ë¥¼ WAVë¡œ ë³€í™˜
                    const chunkBlob = audioBufferToWav(chunkBuffer, 16000); // 16kHzë¡œ ë‹¤ìš´ìƒ˜í”Œë§
                    
                    // Whisper APIë¡œ ì „ì‚¬
                    try {
                        const chunkTranscript = await transcribeWithWhisper(
                            chunkBlob, 
                            `chunk_${i + 1}_of_${numChunks}.wav`
                        );
                        
                        if (chunkTranscript && chunkTranscript.trim()) {
                            combinedTranscript += chunkTranscript + " ";
                            
                            // ì¤‘ê°„ ê²°ê³¼ í‘œì‹œ
                            updateStatus(`âœ… íŒŒíŠ¸ ${i + 1}/${numChunks} ì™„ë£Œ (${chunkTranscript.split(' ').length} ë‹¨ì–´)`, false);
                        }
                        
                        // API ì œí•œ ë°©ì§€ë¥¼ ìœ„í•œ ë”œë ˆì´
                        if (i < numChunks - 1) {
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                        
                    } catch (error) {
                        console.error(`ì²­í¬ ${i + 1} ì²˜ë¦¬ ì‹¤íŒ¨:`, error);
                        // ì‹¤íŒ¨í•œ ì²­í¬ëŠ” ê±´ë„ˆë›°ê³  ê³„ì†
                        updateStatus(`âš ï¸ íŒŒíŠ¸ ${i + 1}/${numChunks} ê±´ë„ˆëœ€`, false);
                    }
                }
                
                return combinedTranscript.trim();
                
            } catch (error) {
                console.error('ì²­í‚¹ ì²˜ë¦¬ ì‹¤íŒ¨:', error);
                throw new Error('ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // ========== ì˜¤ë””ì˜¤ ì²­í¬ ì¶”ì¶œ ==========
        function extractAudioChunk(audioBuffer, startTime, endTime, targetSampleRate = 16000) {
            const startSample = Math.floor(startTime * audioBuffer.sampleRate);
            const endSample = Math.floor(endTime * audioBuffer.sampleRate);
            const chunkLength = endSample - startSample;
            
            // ë‹¤ìš´ìƒ˜í”Œë§ ë¹„ìœ¨ ê³„ì‚°
            const downsampleRatio = audioBuffer.sampleRate / targetSampleRate;
            const newLength = Math.floor(chunkLength / downsampleRatio);
            
            // ìƒˆ ë²„í¼ ìƒì„± (ëª¨ë…¸, 16kHz)
            const chunkBuffer = new AudioContext().createBuffer(
                1, // ëª¨ë…¸
                newLength,
                targetSampleRate
            );
            
            // ì±„ë„ ë°ì´í„° ì¶”ì¶œ ë° ë‹¤ìš´ìƒ˜í”Œë§
            const originalData = audioBuffer.getChannelData(0);
            const chunkData = chunkBuffer.getChannelData(0);
            
            for (let i = 0; i < newLength; i++) {
                const originalIndex = startSample + Math.floor(i * downsampleRatio);
                if (originalIndex < originalData.length) {
                    chunkData[i] = originalData[originalIndex];
                }
            }
            
            return chunkBuffer;
        }

        // ========== WAV ë³€í™˜ (ê°œì„ ëœ ë²„ì „) ==========
        function audioBufferToWav(audioBuffer, targetSampleRate = null) {
            const sampleRate = targetSampleRate || audioBuffer.sampleRate;
            const numChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length;
            const buffer = new ArrayBuffer(44 + length * numChannels * 2);
            const view = new DataView(buffer);
            
            // WAV í—¤ë” ì‘ì„±
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, buffer.byteLength - 8, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // fmt chunk size
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true); // byte rate
            view.setUint16(32, numChannels * 2, true); // block align
            view.setUint16(34, 16, true); // bits per sample
            writeString(36, 'data');
            view.setUint32(40, length * numChannels * 2, true);
            
            // ì˜¤ë””ì˜¤ ë°ì´í„° ì‘ì„±
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = audioBuffer.getChannelData(channel)[i];
                    const value = Math.max(-1, Math.min(1, sample));
                    view.setInt16(offset, value * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        }

        // ========== ì‹œê°„ í¬ë§·íŒ… ==========
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }

        async function transcribeWithWhisper(audioBlob, fileName) {
            // API í‚¤ ìœ íš¨ì„± ì²´í¬
            if (!elements.openaiKey.value || elements.openaiKey.value.length < 20) {
                throw new Error('ìœ íš¨í•œ OpenAI API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
            }

            const formData = new FormData();
            
            // íŒŒì¼ í™•ì¥ìì— ë”°ë¥¸ ì ì ˆí•œ MIME íƒ€ì… ì„¤ì •
            let mimeType = audioBlob.type || 'audio/mpeg';
            if (fileName.toLowerCase().endsWith('.m4a')) {
                mimeType = 'audio/mp4';
            } else if (fileName.toLowerCase().endsWith('.mp3')) {
                mimeType = 'audio/mpeg';
            } else if (fileName.toLowerCase().endsWith('.wav')) {
                mimeType = 'audio/wav';
            } else if (fileName.toLowerCase().endsWith('.webm')) {
                mimeType = 'audio/webm';
            }

            // Blob ìƒì„± ì‹œ ì˜¬ë°”ë¥¸ MIME íƒ€ì… ì‚¬ìš©
            const processedBlob = new Blob([audioBlob], { type: mimeType });
            formData.append('file', processedBlob, fileName);
            formData.append('model', 'whisper-1');
            
            // ì–¸ì–´ ì„¤ì •
            const language = elements.language.value;
            if (language !== 'auto') {
                formData.append('language', language);
            }
            
            formData.append('response_format', 'json');

            try {
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${elements.openaiKey.value}`
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
                    throw new Error(errorData.error?.message || `API í˜¸ì¶œ ì‹¤íŒ¨ (${response.status})`);
                }

                const data = await response.json();
                return data.text;

            } catch (error) {
                if (error.message.includes('quota')) {
                    throw new Error('API ì‚¬ìš©ëŸ‰ í•œë„ ì´ˆê³¼. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                } else if (error.message.includes('401')) {
                    throw new Error('OpenAI API í‚¤ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                } else if (error.message.includes('400')) {
                    throw new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” ì˜¤ë””ì˜¤ í˜•ì‹ì…ë‹ˆë‹¤. MP3, M4A, WAV, WebM íŒŒì¼ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”.');
                }
                throw error;
            }
        }

        async function summarizeWithGemini(transcript) {
            if (!transcript || transcript.trim().length === 0) {
                throw new Error('ìš”ì•½í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
            }

            // ìš”ì•½ ìŠ¤íƒ€ì¼ë³„ í”„ë¡¬í”„íŠ¸
            const stylePrompts = {
                default: `ë‹¤ìŒ íšŒì˜ë¡ í…ìŠ¤íŠ¸ë¥¼ ì•„ë˜ í˜•ì‹ì— ë§ì¶° Markdown ì–‘ì‹ìœ¼ë¡œ ìš”ì•½í•´ ì£¼ì„¸ìš”.

[íšŒì˜ë¡ í…ìŠ¤íŠ¸]
${transcript}

[ìš”ì•½ í˜•ì‹]
### ğŸ“Œ í•µì‹¬ ìš”ì•½
(3-5ì¤„ë¡œ ê°€ì¥ ì¤‘ìš”í•œ ë‚´ìš©ë§Œ)

### ğŸ“ ìƒì„¸ ë‚´ìš©
- (ì£¼ìš” ë…¼ì˜ì‚¬í•­ë“¤ì„ bullet pointë¡œ)

### ğŸš€ Action Items
- (ì‹¤í–‰ í•„ìš” ì‚¬í•­ë“¤)

### ğŸ’¡ ì¶”ê°€ ê³ ë ¤ì‚¬í•­
- (ìˆë‹¤ë©´)`,
                brief: `ë‹¤ìŒ í…ìŠ¤íŠ¸ë¥¼ 3-5ì¤„ë¡œ ê°„ëµí•˜ê²Œ ìš”ì•½í•´ì£¼ì„¸ìš”:\n\n${transcript}`,
                detailed: `ë‹¤ìŒ í…ìŠ¤íŠ¸ë¥¼ ê°€ëŠ¥í•œ ìƒì„¸í•˜ê²Œ ìš”ì•½í•˜ë˜, ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•´ì£¼ì„¸ìš”:\n\n${transcript}`,
                minutes: `ë‹¤ìŒ í…ìŠ¤íŠ¸ë¥¼ ì •ì‹ íšŒì˜ë¡ í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš” (ì¼ì‹œ, ì°¸ì„ì, ì•ˆê±´, ë…¼ì˜ë‚´ìš©, ê²°ì •ì‚¬í•­ ë“±):\n\n${transcript}`
            };

            let prompt = stylePrompts[elements.summaryStyle.value] || stylePrompts.default;
            
            // ì»¤ìŠ¤í…€ í”„ë¡¬í”„íŠ¸ ì¶”ê°€
            if (elements.customPrompt.value.trim()) {
                prompt += `\n\nì¶”ê°€ ìš”ì²­ì‚¬í•­: ${elements.customPrompt.value}`;
            }

            const body = {
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 2048,
                }
            };

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${elements.googleKey.value}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
                    throw new Error(errorData.error?.message || `API í˜¸ì¶œ ì‹¤íŒ¨ (${response.status})`);
                }

                const data = await response.json();
                if (!data.candidates || !data.candidates[0]) {
                    throw new Error('ì‘ë‹µ ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                }

                return data.candidates[0].content.parts[0].text;

            } catch (error) {
                if (error.message.includes('quota')) {
                    throw new Error('Gemini API ì‚¬ìš©ëŸ‰ í•œë„ ì´ˆê³¼. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                } else if (error.message.includes('401') || error.message.includes('403')) {
                    throw new Error('Google AI API í‚¤ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                }
                throw error;
            }
        }

        // ========== ì—ëŸ¬ ì²˜ë¦¬ ==========
        async function handleProcessingError(error) {
            console.error('ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            
            if (retryCount < MAX_RETRIES && !error.message.includes('API í‚¤')) {
                retryCount++;
                updateStatus(`âŒ ${error.message} (ì¬ì‹œë„ ${retryCount}/${MAX_RETRIES})`, false);
                
                // 3ì´ˆ í›„ ìë™ ì¬ì‹œë„
                setTimeout(() => {
                    if (currentTranscript) {
                        summarizeWithGemini(currentTranscript).then(summary => {
                            elements.result.innerText = summary;
                            elements.resultContainer.classList.remove('hidden');
                            updateStatus('âœ… ì¬ì‹œë„ ì„±ê³µ!');
                        }).catch(handleProcessingError);
                    }
                }, 3000);
            } else {
                updateStatus(`âŒ ${error.message}`, false);
                hideProgress();
                
                // ìƒì„¸ ì—ëŸ¬ ì •ë³´ ì œê³µ
                if (error.message.includes('API')) {
                    alert(`API ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n\n${error.message}\n\nAPI í‚¤ë¥¼ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`);
                }
            }
        }

        async function retrySummary() {
            if (!currentTranscript) {
                alert('ìš”ì•½í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ì„ ë‹¤ì‹œ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.');
                return;
            }
            
            try {
                updateStatus('â³ ë‹¤ì‹œ ìš”ì•½ ì¤‘...', true);
                const summary = await summarizeWithGemini(currentTranscript);
                elements.result.innerText = summary;
                updateStatus('âœ… ì¬ìš”ì•½ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!');
            } catch (error) {
                handleProcessingError(error);
            }
        }

        // ========== ì§„í–‰ë¥  í‘œì‹œ ==========
        function showProgress(percent, text) {
            elements.progressContainer.classList.remove('hidden');
            elements.progressBar.style.width = `${percent}%`;
            elements.progressText.textContent = text;
        }

        function hideProgress() {
            setTimeout(() => {
                elements.progressContainer.classList.add('hidden');
                elements.progressBar.style.width = '0%';
            }, 1000);
        }

        // ========== íƒ€ì´ë¨¸ ==========
        function startTimer() {
            seconds = 0;
            elements.timer.textContent = "00:00";
            timerInterval = setInterval(() => {
                seconds++;
                const min = String(Math.floor(seconds / 60)).padStart(2, '0');
                const sec = String(seconds % 60).padStart(2, '0');
                elements.timer.textContent = `${min}:${sec}`;
                
                // 10ë¶„ ì´ˆê³¼ ì‹œ ê²½ê³ 
                if (seconds === 600) {
                    alert('ë…¹ìŒì´ 10ë¶„ì„ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. íŒŒì¼ í¬ê¸°ê°€ ì»¤ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            seconds = 0;
            elements.timer.textContent = "00:00";
        }

        // ========== íˆìŠ¤í† ë¦¬ ê´€ë¦¬ ==========
        function saveToHistory(summary) {
            try {
                const history = JSON.parse(localStorage.getItem('summaryHistory') || '[]');
                const newEntry = {
                    id: Date.now(),
                    fileName: currentFileName || 'Unknown',
                    summary: summary,
                    transcript: currentTranscript,
                    date: new Date().toISOString(),
                    language: elements.language.value,
                    style: elements.summaryStyle.value
                };
                
                history.unshift(newEntry);
                // ìµœê·¼ 20ê°œë§Œ ìœ ì§€
                const trimmedHistory = history.slice(0, 20);
                localStorage.setItem('summaryHistory', JSON.stringify(trimmedHistory));
                
                loadHistory();
                updateStatus('ğŸ“‹ íˆìŠ¤í† ë¦¬ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
                
                // íˆìŠ¤í† ë¦¬ ì„¹ì…˜ ìë™ ì—´ê¸°
                elements.historySection.open = true;
                
            } catch (error) {
                console.error('íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨:', error);
                alert('íˆìŠ¤í† ë¦¬ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì €ì¥ ê³µê°„ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
            }
        }

        function loadHistory() {
            try {
                const history = JSON.parse(localStorage.getItem('summaryHistory') || '[]');
                
                if (history.length === 0) {
                    elements.historyList.innerHTML = '<p class="text-gray-500 text-sm">ì €ì¥ëœ ìš”ì•½ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                    return;
                }

                elements.historyList.innerHTML = history.map(item => {
                    const date = new Date(item.date);
                    const dateStr = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`;
                    
                    return `
                        <div class="history-item p-3 bg-white rounded-lg border cursor-pointer hover:shadow-md transition" 
                             onclick="loadFromHistory(${item.id})">
                            <div class="flex justify-between items-start">
                                <div class="flex-1">
                                    <p class="font-semibold text-sm">${item.fileName}</p>
                                    <p class="text-xs text-gray-500">${dateStr} | ${item.language} | ${item.style}</p>
                                    <p class="text-xs text-gray-600 mt-1 line-clamp-2">${item.summary.substring(0, 100)}...</p>
                                </div>
                                <button onclick="event.stopPropagation(); deleteFromHistory(${item.id})" 
                                        class="text-red-500 hover:text-red-700 ml-2">
                                    ğŸ—‘ï¸
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('íˆìŠ¤í† ë¦¬ ë¡œë“œ ì‹¤íŒ¨:', error);
                elements.historyList.innerHTML = '<p class="text-red-500 text-sm">íˆìŠ¤í† ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
            }
        }

        function loadFromHistory(id) {
            const history = JSON.parse(localStorage.getItem('summaryHistory') || '[]');
            const item = history.find(h => h.id === id);
            
            if (item) {
                elements.result.innerText = item.summary;
                currentTranscript = item.transcript || '';
                currentFileName = item.fileName;
                elements.resultContainer.classList.remove('hidden');
                elements.language.value = item.language || 'ko';
                elements.summaryStyle.value = item.style || 'default';
                updateStatus('ğŸ“‹ íˆìŠ¤í† ë¦¬ì—ì„œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                
                // íˆìŠ¤í† ë¦¬ ì„¹ì…˜ ë‹«ê¸°
                elements.historySection.open = false;
            }
        }

        function deleteFromHistory(id) {
            if (confirm('ì´ í•­ëª©ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                const history = JSON.parse(localStorage.getItem('summaryHistory') || '[]');
                const filtered = history.filter(h => h.id !== id);
                localStorage.setItem('summaryHistory', JSON.stringify(filtered));
                loadHistory();
            }
        }

        function clearHistory() {
            if (confirm('ëª¨ë“  íˆìŠ¤í† ë¦¬ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
                localStorage.removeItem('summaryHistory');
                loadHistory();
                updateStatus('ğŸ—‘ï¸ íˆìŠ¤í† ë¦¬ê°€ ëª¨ë‘ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }

        // ========== ë³µì‚¬ ë° ê³µìœ  ==========
        async function copyToClipboard(text, type = 'í…ìŠ¤íŠ¸') {
            try {
                await navigator.clipboard.writeText(text);
                updateStatus(`âœ… ${type}ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!`);
            } catch (error) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                updateStatus(`âœ… ${type}ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!`);
            }
        }

        async function shareSummary() {
            const shareData = {
                title: `AI íšŒì˜ë¡ ìš”ì•½ - ${currentFileName}`,
                text: elements.result.innerText
            };

            try {
                if (navigator.share && navigator.canShare && navigator.canShare(shareData)) {
                    await navigator.share(shareData);
                    updateStatus('âœ… ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } else {
                    // ê³µìœ  ë§í¬ ìƒì„± (GitHub Pages URL ê¸°ì¤€)
                    const url = window.location.href;
                    const shareUrl = `${url}#shared`;
                    await copyToClipboard(shareUrl, 'ê³µìœ  ë§í¬');
                    alert('ê³µìœ  ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.\nëŒ€ì‹  í˜ì´ì§€ URLì´ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('ê³µìœ  ì‹¤íŒ¨:', error);
                updateStatus('âŒ ê³µìœ ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // ========== PDF ë‹¤ìš´ë¡œë“œ ==========
        async function downloadPdf() {
            const { jsPDF } = window.jspdf;
            const originalStatus = elements.status.innerHTML;
            
            updateStatus('â³ PDF ìƒì„± ì¤‘...', true);

            try {
                // HTML2Canvasë¡œ ìº¡ì²˜
                const canvas = await html2canvas(elements.result, {
                    scale: 2,
                    useCORS: true,
                    backgroundColor: '#ffffff',
                    logging: false
                });

                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });

                // PDF ì„¤ì •
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                const contentWidth = pageWidth - (margin * 2);
                
                // ì œëª© ì¶”ê°€
                pdf.setFontSize(20);
                pdf.text('AI íšŒì˜ë¡ ìš”ì•½', pageWidth / 2, margin, { align: 'center' });
                
                pdf.setFontSize(10);
                pdf.text(`íŒŒì¼: ${currentFileName}`, margin, margin + 10);
                pdf.text(`ìƒì„±ì¼: ${new Date().toLocaleString('ko-KR')}`, margin, margin + 15);
                
                // ì´ë¯¸ì§€ ì¶”ê°€
                const imgProps = pdf.getImageProperties(imgData);
                const imgHeight = (imgProps.height * contentWidth) / imgProps.width;
                
                let yPosition = margin + 25;
                let remainingHeight = imgHeight;
                
                // ì—¬ëŸ¬ í˜ì´ì§€ ì²˜ë¦¬
                while (remainingHeight > 0) {
                    const availableHeight = pageHeight - yPosition - margin;
                    const currentHeight = Math.min(remainingHeight, availableHeight);
                    
                    pdf.addImage(imgData, 'PNG', margin, yPosition, contentWidth, currentHeight);
                    
                    remainingHeight -= currentHeight;
                    
                    if (remainingHeight > 0) {
                        pdf.addPage();
                        yPosition = margin;
                    }
                }

                // íŒŒì¼ ì €ì¥
                const safeFileName = currentFileName.replace(/[^a-zA-Z0-9]/g, '_').replace(/\.[^/.]+$/, '');
                pdf.save(`${safeFileName}_summary_${Date.now()}.pdf`);
                
                updateStatus('âœ… PDFê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!');
                
            } catch (error) {
                console.error('PDF ìƒì„± ì˜¤ë¥˜:', error);
                updateStatus('âŒ PDF ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            } finally {
                setTimeout(() => {
                    elements.status.innerHTML = originalStatus;
                }, 3000);
            }
        }

        // ========== ìœ í‹¸ë¦¬í‹° ==========
        function updateStatus(message, showLoader = false) {
            const loaderHtml = showLoader ? '<div class="loader"></div>' : '';
            elements.status.innerHTML = `${loaderHtml}<span>${message}</span>`;
            
            // ì ‘ê·¼ì„±ì„ ìœ„í•œ aria-live
            elements.status.setAttribute('aria-live', 'polite');
            elements.status.setAttribute('aria-busy', showLoader ? 'true' : 'false');
        }

        // ========== Service Worker (ì˜¤í”„ë¼ì¸ ì§€ì›) ==========
        if ('serviceWorker' in navigator && location.protocol === 'https:') {
            // GitHub PagesëŠ” HTTPSì´ë¯€ë¡œ Service Worker ì‚¬ìš© ê°€ëŠ¥
            navigator.serviceWorker.register('sw.js').catch(err => {
                console.log('Service Worker ë“±ë¡ ì‹¤íŒ¨:', err);
            });
        }

        // ========== ì „ì—­ í•¨ìˆ˜ (ì¸ë¼ì¸ onclickìš©) ==========
        window.loadFromHistory = loadFromHistory;
        window.deleteFromHistory = deleteFromHistory;
    </script>
</body>
</html>
