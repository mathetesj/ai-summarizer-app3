<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 회의록 요약 - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @keyframes pulse { 
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 
            70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); } 
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } 
        }
        .recording { animation: pulse 1.5s infinite; }
        .saved-indicator { transition: opacity 1s; }
        .loader { 
            border: 4px solid #f3f3f3; 
            border-radius: 50%; 
            border-top: 4px solid #3498db; 
            width: 24px; 
            height: 24px; 
            animation: spin 2s linear infinite; 
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
        .history-item:hover {
            background-color: #f3f4f6;
        }
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white rounded-2xl shadow-lg p-6 md:p-8 w-full max-w-4xl">
        <!-- 헤더 -->
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-blue-600">🎙️ AI 회의록 요약</h1>
            <p class="text-gray-500 mt-2">회의 녹음 또는 파일 업로드 후 AI로 요약하고 공유하세요.</p>
            <!-- 네트워크 상태 표시 -->
            <div id="networkStatus" class="mt-2 text-sm"></div>
        </header>

        <!-- API 키 입력 섹션 -->
        <div class="space-y-4 mb-6 bg-blue-50 p-4 rounded-lg">
            <div>
                <label for="openai_key" class="block text-sm font-medium text-gray-700">
                    OpenAI API Key (Whisper 용)
                    <a href="https://platform.openai.com/api-keys" target="_blank" class="text-blue-500 text-xs ml-2">키 발급받기 →</a>
                </label>
                <div class="relative mt-1">
                    <input 
                        type="password" 
                        id="openai_key" 
                        class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500" 
                        placeholder="sk-..."
                        aria-label="OpenAI API 키 입력">
                    <button 
                        id="toggleOpenAI" 
                        class="absolute right-10 top-2 text-gray-500 hover:text-gray-700"
                        aria-label="API 키 표시/숨기기">
                        👁️
                    </button>
                    <span id="openai_saved" class="saved-indicator absolute right-3 top-2 text-xs text-green-500 opacity-0">Saved!</span>
                </div>
            </div>
            <div>
                <label for="google_key" class="block text-sm font-medium text-gray-700">
                    Google AI API Key (Gemini 용)
                    <a href="https://makersuite.google.com/app/apikey" target="_blank" class="text-blue-500 text-xs ml-2">키 발급받기 →</a>
                </label>
                <div class="relative mt-1">
                    <input 
                        type="password" 
                        id="google_key" 
                        class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500" 
                        placeholder="AIza..."
                        aria-label="Google AI API 키 입력">
                    <button 
                        id="toggleGoogle" 
                        class="absolute right-10 top-2 text-gray-500 hover:text-gray-700"
                        aria-label="API 키 표시/숨기기">
                        👁️
                    </button>
                    <span id="google_saved" class="saved-indicator absolute right-3 top-2 text-xs text-green-500 opacity-0">Saved!</span>
                </div>
            </div>
            <p class="text-xs text-gray-600 text-center bg-yellow-50 p-2 rounded">
                ⚠️ API 키는 브라우저에 로컬 저장됩니다. GitHub Pages는 서버가 없어 클라이언트에서 직접 API를 호출합니다.<br>
                프로덕션 환경에서는 반드시 백엔드 서버를 통해 API를 호출하세요.
            </p>
        </div>

        <!-- 메인 기능 섹션 -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- 실시간 녹음 -->
            <div class="text-center p-4 border rounded-lg">
                <h2 class="font-semibold mb-4">🔴 실시간 녹음</h2>
                <button 
                    id="recordBtn" 
                    class="w-24 h-24 rounded-full bg-red-500 text-white flex flex-col items-center justify-center mx-auto transition-colors duration-300 hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300"
                    aria-label="녹음 시작/중지"
                    aria-pressed="false">
                    <span aria-live="polite">녹음</span>
                    <span id="timer" class="text-xs mt-1">00:00</span>
                </button>
                <!-- 오디오 품질 설정 -->
                <div class="mt-4">
                    <label class="text-xs text-gray-600">
                        <input type="checkbox" id="highQuality" checked> 고품질 녹음
                    </label>
                </div>
            </div>
            
            <!-- 파일 업로드 -->
            <div class="text-center p-4 border rounded-lg flex flex-col justify-center">
                <h2 class="font-semibold mb-4">📁 파일 업로드</h2>
                <input 
                    type="file" 
                    id="fileUploader" 
                    class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" 
                    accept="audio/*,video/*,.m4a,.mp3,.wav,.webm,.mp4,.mpeg,.mpga,.ogg,.oga,.flac"
                    aria-label="오디오 파일 선택">
                <p class="text-xs text-gray-500 mt-2">지원: MP3, M4A, WAV, WebM, MP4, OGG, FLAC (최대 25MB)</p>
            </div>
        </div>

        <!-- 고급 설정 -->
        <details class="mt-4 bg-gray-50 p-4 rounded-lg">
            <summary class="cursor-pointer font-semibold text-gray-700">⚙️ 고급 설정</summary>
            <div class="mt-4 space-y-3">
                <div>
                    <label for="language" class="block text-sm font-medium text-gray-700">전사 언어</label>
                    <select id="language" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
                        <option value="ko">한국어</option>
                        <option value="en">영어</option>
                        <option value="ja">일본어</option>
                        <option value="zh">중국어</option>
                        <option value="auto">자동 감지</option>
                    </select>
                </div>
                <div>
                    <label for="summaryStyle" class="block text-sm font-medium text-gray-700">요약 스타일</label>
                    <select id="summaryStyle" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
                        <option value="default">기본 (핵심요약 + 상세내용 + Action Items)</option>
                        <option value="brief">간략 (핵심만)</option>
                        <option value="detailed">상세 (모든 내용 포함)</option>
                        <option value="minutes">회의록 형식</option>
                    </select>
                </div>
                <div>
                    <label for="customPrompt" class="block text-sm font-medium text-gray-700">커스텀 프롬프트 (선택사항)</label>
                    <textarea 
                        id="customPrompt" 
                        rows="3" 
                        class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
                        placeholder="예: 기술적인 내용 위주로 요약해주세요..."></textarea>
                </div>
            </div>
        </details>

        <!-- 상태 표시 -->
        <div id="status" class="mt-6 text-center font-semibold text-gray-600 min-h-[24px] flex items-center justify-center gap-2"></div>
        
        <!-- 진행률 표시 -->
        <div id="progressContainer" class="hidden mt-2">
            <div class="w-full bg-gray-200 rounded-full h-2.5">
                <div id="progressBar" class="progress-bar bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="progressText" class="text-xs text-gray-500 mt-1 text-center"></p>
        </div>

        <!-- 결과 컨테이너 -->
        <div id="result-container" class="mt-4 hidden">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xl font-bold">✨ 요약 결과</h3>
                <button id="saveToHistory" class="text-sm bg-gray-200 px-3 py-1 rounded hover:bg-gray-300">
                    📋 히스토리에 저장
                </button>
            </div>
            <div id="result" class="whitespace-pre-wrap bg-gray-50 p-4 rounded-lg border max-h-96 overflow-y-auto"></div>
            
            <!-- 액션 버튼들 -->
            <div class="mt-4 flex flex-wrap justify-center gap-3">
                <button id="copyBtn" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition">
                    📋 복사
                </button>
                <button id="copyMarkdownBtn" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition">
                    📝 Markdown 복사
                </button>
                <button id="shareBtn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition">
                    🔗 공유
                </button>
                <button id="pdfBtn" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition">
                    📄 PDF
                </button>
                <button id="retryBtn" class="bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600 transition">
                    🔄 다시 요약
                </button>
            </div>
        </div>

        <!-- 히스토리 섹션 -->
        <details id="historySection" class="mt-6 bg-gray-50 p-4 rounded-lg">
            <summary class="cursor-pointer font-semibold text-gray-700">📚 최근 요약 히스토리</summary>
            <div id="historyList" class="mt-4 space-y-2 max-h-60 overflow-y-auto"></div>
            <button id="clearHistory" class="mt-2 text-xs text-red-500 hover:text-red-700">히스토리 모두 삭제</button>
        </details>
    </div>

    <script>
        // ========== 전역 변수 ==========
        const elements = {
            openaiKey: document.getElementById('openai_key'),
            googleKey: document.getElementById('google_key'),
            recordBtn: document.getElementById('recordBtn'),
            timer: document.getElementById('timer'),
            fileUploader: document.getElementById('fileUploader'),
            status: document.getElementById('status'),
            resultContainer: document.getElementById('result-container'),
            result: document.getElementById('result'),
            progressContainer: document.getElementById('progressContainer'),
            progressBar: document.getElementById('progressBar'),
            progressText: document.getElementById('progressText'),
            networkStatus: document.getElementById('networkStatus'),
            language: document.getElementById('language'),
            summaryStyle: document.getElementById('summaryStyle'),
            customPrompt: document.getElementById('customPrompt'),
            highQuality: document.getElementById('highQuality'),
            historyList: document.getElementById('historyList'),
            historySection: document.getElementById('historySection')
        };

        let mediaRecorder, audioChunks = [], isRecording = false, timerInterval, seconds = 0;
        let currentFileName = '', currentTranscript = '', retryCount = 0;
        const MAX_RETRIES = 3;

        // ========== 초기화 및 이벤트 리스너 ==========
        window.addEventListener('DOMContentLoaded', init);

        function init() {
            loadApiKeys();
            loadHistory();
            updateNetworkStatus();
            setupEventListeners();
            checkBrowserCompatibility();
        }

        function setupEventListeners() {
            // API 키 관련
            elements.openaiKey.addEventListener('input', () => saveApiKey('openaiApiKey', elements.openaiKey.value, document.getElementById('openai_saved')));
            elements.googleKey.addEventListener('input', () => saveApiKey('googleApiKey', elements.googleKey.value, document.getElementById('google_saved')));
            
            // 토글 버튼
            document.getElementById('toggleOpenAI').addEventListener('click', () => togglePasswordVisibility('openai_key'));
            document.getElementById('toggleGoogle').addEventListener('click', () => togglePasswordVisibility('google_key'));
            
            // 메인 기능
            elements.recordBtn.addEventListener('click', handleRecord);
            elements.recordBtn.addEventListener('keydown', handleKeyPress);
            elements.fileUploader.addEventListener('change', handleFileUpload);
            
            // 결과 액션
            document.getElementById('copyBtn')?.addEventListener('click', () => copyToClipboard(elements.result.innerText, '요약'));
            document.getElementById('copyMarkdownBtn')?.addEventListener('click', () => copyToClipboard(elements.result.innerText, 'Markdown'));
            document.getElementById('shareBtn')?.addEventListener('click', shareSummary);
            document.getElementById('pdfBtn')?.addEventListener('click', downloadPdf);
            document.getElementById('retryBtn')?.addEventListener('click', retrySummary);
            document.getElementById('saveToHistory')?.addEventListener('click', () => saveToHistory(elements.result.innerText));
            
            // 히스토리
            document.getElementById('clearHistory')?.addEventListener('click', clearHistory);
            
            // 네트워크 상태
            window.addEventListener('online', updateNetworkStatus);
            window.addEventListener('offline', updateNetworkStatus);
        }

        // ========== 브라우저 호환성 체크 ==========
        function checkBrowserCompatibility() {
            const warnings = [];
            if (!navigator.mediaDevices?.getUserMedia) {
                warnings.push('마이크 녹음 기능을 지원하지 않는 브라우저입니다.');
            }
            if (!window.MediaRecorder) {
                warnings.push('MediaRecorder API를 지원하지 않습니다.');
            }
            if (warnings.length > 0) {
                updateStatus(`⚠️ ${warnings.join(' ')}`, false);
            }
        }

        // ========== API 키 관리 ==========
        function loadApiKeys() {
            elements.openaiKey.value = localStorage.getItem('openaiApiKey') || '';
            elements.googleKey.value = localStorage.getItem('googleApiKey') || '';
        }

        function saveApiKey(keyName, value, indicatorEl) {
            try {
                localStorage.setItem(keyName, value);
                indicatorEl.style.opacity = '1';
                setTimeout(() => { indicatorEl.style.opacity = '0'; }, 2000);
            } catch (e) {
                console.error('localStorage 저장 실패:', e);
                alert('브라우저 설정에서 localStorage를 활성화해주세요.');
            }
        }

        function checkApiKeys() {
            if (!elements.openaiKey.value || !elements.googleKey.value) {
                alert('API 키를 먼저 입력해주세요!\n\n1. OpenAI: https://platform.openai.com/api-keys\n2. Google AI: https://makersuite.google.com/app/apikey');
                return false;
            }
            if (elements.openaiKey.value.length < 20 || !elements.openaiKey.value.startsWith('sk-')) {
                alert('유효한 OpenAI API 키를 입력해주세요. (sk-로 시작)');
                return false;
            }
            if (elements.googleKey.value.length < 20 || !elements.googleKey.value.startsWith('AIza')) {
                alert('유효한 Google AI API 키를 입력해주세요. (AIza로 시작)');
                return false;
            }
            return true;
        }

        function togglePasswordVisibility(inputId) {
            const input = document.getElementById(inputId);
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        // ========== 네트워크 상태 ==========
        function updateNetworkStatus() {
            const online = navigator.onLine;
            elements.networkStatus.innerHTML = online 
                ? '<span class="text-green-500">🟢 온라인</span>' 
                : '<span class="text-red-500">🔴 오프라인 - 인터넷 연결을 확인하세요</span>';
            
            if (!online) {
                updateStatus('❌ 인터넷 연결이 끊어졌습니다. 연결을 확인해주세요.');
            }
        }

        // ========== 녹음 관리 ==========
        async function handleRecord() {
            if (!checkApiKeys()) return;
            if (!navigator.onLine) {
                alert('인터넷 연결을 확인해주세요.');
                return;
            }

            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            try {
                const constraints = {
                    audio: elements.highQuality.checked ? {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100,
                        channelCount: 2
                    } : true
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // 브라우저별 최적 MIME 타입 선택
                const mimeTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/ogg;codecs=opus',
                    'audio/mp4'
                ];
                
                let selectedMimeType = 'audio/webm';
                for (const mimeType of mimeTypes) {
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        selectedMimeType = mimeType;
                        break;
                    }
                }

                mediaRecorder = new MediaRecorder(stream, { mimeType: selectedMimeType });
                audioChunks = [];
                
                mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };
                
                mediaRecorder.onstop = () => {
                    currentFileName = `recording_${new Date().toISOString()}.webm`;
                    const audioBlob = new Blob(audioChunks, { type: selectedMimeType });
                    processAudio(audioBlob, currentFileName);
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start(1000); // 1초마다 데이터 수집
                elements.recordBtn.classList.add('recording');
                elements.recordBtn.setAttribute('aria-pressed', 'true');
                isRecording = true;
                startTimer();
                updateStatus('🔴 녹음 중입니다... (다시 클릭하면 중지)');
            } catch (err) {
                console.error('녹음 시작 실패:', err);
                updateStatus('❌ 마이크 접근 권한을 허용해주세요.');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                elements.recordBtn.classList.remove('recording');
                elements.recordBtn.setAttribute('aria-pressed', 'false');
                isRecording = false;
                stopTimer();
                updateStatus('⏹️ 녹음이 중지되었습니다.');
            }
        }

        function handleKeyPress(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleRecord();
            }
        }

        // ========== 파일 업로드 관리 ==========
        async function handleFileUpload(event) {
            if (!checkApiKeys()) {
                event.target.value = '';
                return;
            }
            
            const file = event.target.files[0];
            if (!file) return;

            // 파일 크기 체크
            const MAX_SIZE = 25 * 1024 * 1024;
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            
            if (file.size > MAX_SIZE) {
                // 25MB 초과 시 자동 처리 안내
                const message = `📦 대용량 파일 감지 (${sizeMB}MB)\n\n자동으로 압축 및 분할 처리를 진행합니다.\n처리 시간은 파일 크기에 따라 달라집니다.\n\n예상 시간:\n- 25-50MB: 2-5분\n- 50-100MB: 5-10분\n- 100MB+: 10분 이상\n\n계속하시겠습니까?`;
                
                if (!confirm(message)) {
                    event.target.value = '';
                    return;
                }
                
                // 큰 파일 처리 중 브라우저 종료 경고
                window.onbeforeunload = function() {
                    return "파일 처리가 진행 중입니다. 페이지를 떠나시겠습니까?";
                };
            }

            currentFileName = file.name;
            
            // M4A 및 기타 형식 처리
            if (file.name.toLowerCase().endsWith('.m4a') || 
                file.type === 'audio/x-m4a' || 
                file.type === 'audio/mp4' ||
                file.type === 'audio/mpeg' ||
                file.type === 'video/mp4') {
                
                updateStatus(`⏳ ${sizeMB}MB 파일 처리 중...`, true);
                
                try {
                    await processAudio(file, currentFileName);
                } catch (error) {
                    console.error('파일 처리 실패:', error);
                    updateStatus(`❌ 파일 처리 실패: ${error.message}`);
                } finally {
                    // 처리 완료 후 경고 제거
                    window.onbeforeunload = null;
                }
            } else {
                // 기타 오디오 형식 직접 처리
                await processAudio(file, currentFileName);
                window.onbeforeunload = null;
            }
        }

        // ========== 오디오 처리 ==========
        async function processAudio(audioBlob, fileName) {
            updateStatus('⏳ 오디오 파일 처리 준비 중...', true);
            showProgress(0, '준비 중...');
            elements.resultContainer.classList.add('hidden');
            retryCount = 0;

            try {
                const MAX_SIZE = 25 * 1024 * 1024; // 25MB
                let processedBlob = audioBlob;
                let fullTranscript = "";

                // 파일 크기 체크 및 처리
                if (audioBlob.size > MAX_SIZE) {
                    const sizeMB = (audioBlob.size / 1024 / 1024).toFixed(2);
                    updateStatus(`📦 대용량 파일 감지 (${sizeMB}MB) - 자동 처리 중...`, true);
                    
                    // 압축 시도
                    updateStatus('🔄 오디오 압축 시도 중...', true);
                    showProgress(10, '압축 중...');
                    processedBlob = await compressAudio(audioBlob, fileName);
                    
                    const compressedSizeMB = (processedBlob.size / 1024 / 1024).toFixed(2);
                    updateStatus(`✅ 압축 완료: ${sizeMB}MB → ${compressedSizeMB}MB`, true);
                    
                    // 압축 후에도 25MB 초과 시 청킹
                    if (processedBlob.size > MAX_SIZE) {
                        updateStatus('📂 파일 분할 처리 중... (시간이 걸릴 수 있습니다)', true);
                        fullTranscript = await processLargeAudioInChunks(processedBlob, fileName);
                    } else {
                        // 압축 성공, 단일 처리
                        showProgress(30, '음성 인식 중...');
                        fullTranscript = await transcribeWithWhisper(processedBlob, fileName);
                    }
                } else {
                    // 25MB 이하, 직접 처리
                    showProgress(30, '음성 인식 중...');
                    fullTranscript = await transcribeWithWhisper(audioBlob, fileName);
                }

                currentTranscript = fullTranscript;
                
                if (!currentTranscript || currentTranscript.trim().length === 0) {
                    throw new Error('음성 인식 결과가 없습니다. 오디오 파일을 확인해주세요.');
                }

                // 요약
                updateStatus('⏳ Gemini AI가 텍스트를 요약 중...', true);
                showProgress(70, '요약 생성 중...');
                const summary = await summarizeWithGemini(currentTranscript);

                // 결과 표시
                showProgress(100, '완료!');
                elements.result.innerText = summary;
                elements.resultContainer.classList.remove('hidden');
                updateStatus('✅ 요약이 완료되었습니다!');
                hideProgress();

                // 자동 저장 옵션
                if (confirm('요약 결과를 히스토리에 자동 저장하시겠습니까?')) {
                    saveToHistory(summary);
                }

            } catch (error) {
                console.error('처리 오류:', error);
                handleProcessingError(error);
            } finally {
                elements.fileUploader.value = '';
            }
        }

        // ========== 오디오 압축 ==========
        async function compressAudio(audioBlob, fileName) {
            try {
                updateStatus('🎵 오디오 디코딩 중...', true);
                
                // AudioContext로 디코딩
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // 압축 설정 계산
                const originalSampleRate = audioBuffer.sampleRate;
                const targetSampleRate = 16000; // Whisper API 최적 샘플레이트
                const channels = 1; // 모노로 변환
                
                // 다운샘플링 및 모노 변환
                const offlineContext = new OfflineAudioContext(
                    channels, 
                    Math.floor(audioBuffer.duration * targetSampleRate),
                    targetSampleRate
                );
                
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                
                // 압축 (다이나믹 레인지 압축)
                const compressor = offlineContext.createDynamicsCompressor();
                compressor.threshold.value = -24;
                compressor.knee.value = 30;
                compressor.ratio.value = 12;
                compressor.attack.value = 0.003;
                compressor.release.value = 0.25;
                
                source.connect(compressor);
                compressor.connect(offlineContext.destination);
                source.start(0);
                
                const renderedBuffer = await offlineContext.startRendering();
                
                // WAV로 변환 (압축된 포맷)
                const wavBlob = audioBufferToWav(renderedBuffer, targetSampleRate);
                
                // MP3로 추가 압축 시도 (lamejs 사용하지 않고 WAV 유지)
                // Whisper API는 WAV를 잘 처리하므로 WAV 유지
                
                return wavBlob;
                
            } catch (error) {
                console.error('압축 실패, 원본 사용:', error);
                return audioBlob; // 압축 실패 시 원본 반환
            }
        }

        // ========== 대용량 파일 청킹 처리 ==========
        async function processLargeAudioInChunks(audioBlob, fileName) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                const duration = audioBuffer.duration;
                const sampleRate = audioBuffer.sampleRate;
                const numChannels = audioBuffer.numberOfChannels;
                
                // 청크 설정 (5분 단위로 분할, 최대 24MB)
                const chunkDuration = Math.min(300, duration); // 5분 또는 전체 길이
                const MAX_CHUNK_SIZE = 24 * 1024 * 1024; // 24MB (안전 마진)
                
                // 청크 크기 계산
                const bytesPerSecond = sampleRate * numChannels * 2; // 16-bit = 2 bytes
                const optimalChunkDuration = Math.min(
                    chunkDuration,
                    MAX_CHUNK_SIZE / bytesPerSecond
                );
                
                const numChunks = Math.ceil(duration / optimalChunkDuration);
                let combinedTranscript = "";
                
                updateStatus(`🔪 오디오를 ${numChunks}개 부분으로 나누어 처리합니다...`, true);
                
                for (let i = 0; i < numChunks; i++) {
                    const startTime = i * optimalChunkDuration;
                    const endTime = Math.min((i + 1) * optimalChunkDuration, duration);
                    const chunkProgress = 30 + (40 * (i / numChunks)); // 30-70% 구간
                    
                    showProgress(chunkProgress, `청크 ${i + 1}/${numChunks} 처리 중...`);
                    updateStatus(`📝 파트 ${i + 1}/${numChunks} 전사 중... (${formatTime(startTime)} - ${formatTime(endTime)})`, true);
                    
                    // 청크 추출
                    const chunkBuffer = extractAudioChunk(audioBuffer, startTime, endTime, sampleRate);
                    
                    // 청크를 WAV로 변환
                    const chunkBlob = audioBufferToWav(chunkBuffer, 16000); // 16kHz로 다운샘플링
                    
                    // Whisper API로 전사
                    try {
                        const chunkTranscript = await transcribeWithWhisper(
                            chunkBlob, 
                            `chunk_${i + 1}_of_${numChunks}.wav`
                        );
                        
                        if (chunkTranscript && chunkTranscript.trim()) {
                            combinedTranscript += chunkTranscript + " ";
                            
                            // 중간 결과 표시
                            updateStatus(`✅ 파트 ${i + 1}/${numChunks} 완료 (${chunkTranscript.split(' ').length} 단어)`, false);
                        }
                        
                        // API 제한 방지를 위한 딜레이
                        if (i < numChunks - 1) {
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                        
                    } catch (error) {
                        console.error(`청크 ${i + 1} 처리 실패:`, error);
                        // 실패한 청크는 건너뛰고 계속
                        updateStatus(`⚠️ 파트 ${i + 1}/${numChunks} 건너뜀`, false);
                    }
                }
                
                return combinedTranscript.trim();
                
            } catch (error) {
                console.error('청킹 처리 실패:', error);
                throw new Error('대용량 파일 처리 중 오류가 발생했습니다.');
            }
        }

        // ========== 오디오 청크 추출 ==========
        function extractAudioChunk(audioBuffer, startTime, endTime, targetSampleRate = 16000) {
            const startSample = Math.floor(startTime * audioBuffer.sampleRate);
            const endSample = Math.floor(endTime * audioBuffer.sampleRate);
            const chunkLength = endSample - startSample;
            
            // 다운샘플링 비율 계산
            const downsampleRatio = audioBuffer.sampleRate / targetSampleRate;
            const newLength = Math.floor(chunkLength / downsampleRatio);
            
            // 새 버퍼 생성 (모노, 16kHz)
            const chunkBuffer = new AudioContext().createBuffer(
                1, // 모노
                newLength,
                targetSampleRate
            );
            
            // 채널 데이터 추출 및 다운샘플링
            const originalData = audioBuffer.getChannelData(0);
            const chunkData = chunkBuffer.getChannelData(0);
            
            for (let i = 0; i < newLength; i++) {
                const originalIndex = startSample + Math.floor(i * downsampleRatio);
                if (originalIndex < originalData.length) {
                    chunkData[i] = originalData[originalIndex];
                }
            }
            
            return chunkBuffer;
        }

        // ========== WAV 변환 (개선된 버전) ==========
        function audioBufferToWav(audioBuffer, targetSampleRate = null) {
            const sampleRate = targetSampleRate || audioBuffer.sampleRate;
            const numChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length;
            const buffer = new ArrayBuffer(44 + length * numChannels * 2);
            const view = new DataView(buffer);
            
            // WAV 헤더 작성
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, buffer.byteLength - 8, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // fmt chunk size
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true); // byte rate
            view.setUint16(32, numChannels * 2, true); // block align
            view.setUint16(34, 16, true); // bits per sample
            writeString(36, 'data');
            view.setUint32(40, length * numChannels * 2, true);
            
            // 오디오 데이터 작성
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = audioBuffer.getChannelData(channel)[i];
                    const value = Math.max(-1, Math.min(1, sample));
                    view.setInt16(offset, value * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        }

        // ========== 시간 포맷팅 ==========
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }

        async function transcribeWithWhisper(audioBlob, fileName) {
            // API 키 유효성 체크
            if (!elements.openaiKey.value || elements.openaiKey.value.length < 20) {
                throw new Error('유효한 OpenAI API 키를 입력해주세요');
            }

            const formData = new FormData();
            
            // 파일 확장자에 따른 적절한 MIME 타입 설정
            let mimeType = audioBlob.type || 'audio/mpeg';
            if (fileName.toLowerCase().endsWith('.m4a')) {
                mimeType = 'audio/mp4';
            } else if (fileName.toLowerCase().endsWith('.mp3')) {
                mimeType = 'audio/mpeg';
            } else if (fileName.toLowerCase().endsWith('.wav')) {
                mimeType = 'audio/wav';
            } else if (fileName.toLowerCase().endsWith('.webm')) {
                mimeType = 'audio/webm';
            }

            // Blob 생성 시 올바른 MIME 타입 사용
            const processedBlob = new Blob([audioBlob], { type: mimeType });
            formData.append('file', processedBlob, fileName);
            formData.append('model', 'whisper-1');
            
            // 언어 설정
            const language = elements.language.value;
            if (language !== 'auto') {
                formData.append('language', language);
            }
            
            formData.append('response_format', 'json');

            try {
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${elements.openaiKey.value}`
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
                    throw new Error(errorData.error?.message || `API 호출 실패 (${response.status})`);
                }

                const data = await response.json();
                return data.text;

            } catch (error) {
                if (error.message.includes('quota')) {
                    throw new Error('API 사용량 한도 초과. 잠시 후 다시 시도해주세요.');
                } else if (error.message.includes('401')) {
                    throw new Error('OpenAI API 키가 올바르지 않습니다.');
                } else if (error.message.includes('400')) {
                    throw new Error('지원하지 않는 오디오 형식입니다. MP3, M4A, WAV, WebM 파일을 사용해주세요.');
                }
                throw error;
            }
        }

        async function summarizeWithGemini(transcript) {
            if (!transcript || transcript.trim().length === 0) {
                throw new Error('요약할 텍스트가 없습니다.');
            }

            // 요약 스타일별 프롬프트
            const stylePrompts = {
                default: `다음 회의록 텍스트를 아래 형식에 맞춰 Markdown 양식으로 요약해 주세요.

[회의록 텍스트]
${transcript}

[요약 형식]
### 📌 핵심 요약
(3-5줄로 가장 중요한 내용만)

### 📝 상세 내용
- (주요 논의사항들을 bullet point로)

### 🚀 Action Items
- (실행 필요 사항들)

### 💡 추가 고려사항
- (있다면)`,
                brief: `다음 텍스트를 3-5줄로 간략하게 요약해주세요:\n\n${transcript}`,
                detailed: `다음 텍스트를 가능한 상세하게 요약하되, 체계적으로 정리해주세요:\n\n${transcript}`,
                minutes: `다음 텍스트를 정식 회의록 형식으로 작성해주세요 (일시, 참석자, 안건, 논의내용, 결정사항 등):\n\n${transcript}`
            };

            let prompt = stylePrompts[elements.summaryStyle.value] || stylePrompts.default;
            
            // 커스텀 프롬프트 추가
            if (elements.customPrompt.value.trim()) {
                prompt += `\n\n추가 요청사항: ${elements.customPrompt.value}`;
            }

            const body = {
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 2048,
                }
            };

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${elements.googleKey.value}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
                    throw new Error(errorData.error?.message || `API 호출 실패 (${response.status})`);
                }

                const data = await response.json();
                if (!data.candidates || !data.candidates[0]) {
                    throw new Error('응답 데이터가 올바르지 않습니다.');
                }

                return data.candidates[0].content.parts[0].text;

            } catch (error) {
                if (error.message.includes('quota')) {
                    throw new Error('Gemini API 사용량 한도 초과. 잠시 후 다시 시도해주세요.');
                } else if (error.message.includes('401') || error.message.includes('403')) {
                    throw new Error('Google AI API 키가 올바르지 않습니다.');
                }
                throw error;
            }
        }

        // ========== 에러 처리 ==========
        async function handleProcessingError(error) {
            console.error('처리 오류:', error);
            
            if (retryCount < MAX_RETRIES && !error.message.includes('API 키')) {
                retryCount++;
                updateStatus(`❌ ${error.message} (재시도 ${retryCount}/${MAX_RETRIES})`, false);
                
                // 3초 후 자동 재시도
                setTimeout(() => {
                    if (currentTranscript) {
                        summarizeWithGemini(currentTranscript).then(summary => {
                            elements.result.innerText = summary;
                            elements.resultContainer.classList.remove('hidden');
                            updateStatus('✅ 재시도 성공!');
                        }).catch(handleProcessingError);
                    }
                }, 3000);
            } else {
                updateStatus(`❌ ${error.message}`, false);
                hideProgress();
                
                // 상세 에러 정보 제공
                if (error.message.includes('API')) {
                    alert(`API 오류가 발생했습니다.\n\n${error.message}\n\nAPI 키를 확인하고 다시 시도해주세요.`);
                }
            }
        }

        async function retrySummary() {
            if (!currentTranscript) {
                alert('요약할 텍스트가 없습니다. 파일을 다시 업로드해주세요.');
                return;
            }
            
            try {
                updateStatus('⏳ 다시 요약 중...', true);
                const summary = await summarizeWithGemini(currentTranscript);
                elements.result.innerText = summary;
                updateStatus('✅ 재요약이 완료되었습니다!');
            } catch (error) {
                handleProcessingError(error);
            }
        }

        // ========== 진행률 표시 ==========
        function showProgress(percent, text) {
            elements.progressContainer.classList.remove('hidden');
            elements.progressBar.style.width = `${percent}%`;
            elements.progressText.textContent = text;
        }

        function hideProgress() {
            setTimeout(() => {
                elements.progressContainer.classList.add('hidden');
                elements.progressBar.style.width = '0%';
            }, 1000);
        }

        // ========== 타이머 ==========
        function startTimer() {
            seconds = 0;
            elements.timer.textContent = "00:00";
            timerInterval = setInterval(() => {
                seconds++;
                const min = String(Math.floor(seconds / 60)).padStart(2, '0');
                const sec = String(seconds % 60).padStart(2, '0');
                elements.timer.textContent = `${min}:${sec}`;
                
                // 10분 초과 시 경고
                if (seconds === 600) {
                    alert('녹음이 10분을 초과했습니다. 파일 크기가 커질 수 있습니다.');
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            seconds = 0;
            elements.timer.textContent = "00:00";
        }

        // ========== 히스토리 관리 ==========
        function saveToHistory(summary) {
            try {
                const history = JSON.parse(localStorage.getItem('summaryHistory') || '[]');
                const newEntry = {
                    id: Date.now(),
                    fileName: currentFileName || 'Unknown',
                    summary: summary,
                    transcript: currentTranscript,
                    date: new Date().toISOString(),
                    language: elements.language.value,
                    style: elements.summaryStyle.value
                };
                
                history.unshift(newEntry);
                // 최근 20개만 유지
                const trimmedHistory = history.slice(0, 20);
                localStorage.setItem('summaryHistory', JSON.stringify(trimmedHistory));
                
                loadHistory();
                updateStatus('📋 히스토리에 저장되었습니다!');
                
                // 히스토리 섹션 자동 열기
                elements.historySection.open = true;
                
            } catch (error) {
                console.error('히스토리 저장 실패:', error);
                alert('히스토리 저장에 실패했습니다. 브라우저 저장 공간을 확인해주세요.');
            }
        }

        function loadHistory() {
            try {
                const history = JSON.parse(localStorage.getItem('summaryHistory') || '[]');
                
                if (history.length === 0) {
                    elements.historyList.innerHTML = '<p class="text-gray-500 text-sm">저장된 요약이 없습니다.</p>';
                    return;
                }

                elements.historyList.innerHTML = history.map(item => {
                    const date = new Date(item.date);
                    const dateStr = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`;
                    
                    return `
                        <div class="history-item p-3 bg-white rounded-lg border cursor-pointer hover:shadow-md transition" 
                             onclick="loadFromHistory(${item.id})">
                            <div class="flex justify-between items-start">
                                <div class="flex-1">
                                    <p class="font-semibold text-sm">${item.fileName}</p>
                                    <p class="text-xs text-gray-500">${dateStr} | ${item.language} | ${item.style}</p>
                                    <p class="text-xs text-gray-600 mt-1 line-clamp-2">${item.summary.substring(0, 100)}...</p>
                                </div>
                                <button onclick="event.stopPropagation(); deleteFromHistory(${item.id})" 
                                        class="text-red-500 hover:text-red-700 ml-2">
                                    🗑️
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('히스토리 로드 실패:', error);
                elements.historyList.innerHTML = '<p class="text-red-500 text-sm">히스토리를 불러올 수 없습니다.</p>';
            }
        }

        function loadFromHistory(id) {
            const history = JSON.parse(localStorage.getItem('summaryHistory') || '[]');
            const item = history.find(h => h.id === id);
            
            if (item) {
                elements.result.innerText = item.summary;
                currentTranscript = item.transcript || '';
                currentFileName = item.fileName;
                elements.resultContainer.classList.remove('hidden');
                elements.language.value = item.language || 'ko';
                elements.summaryStyle.value = item.style || 'default';
                updateStatus('📋 히스토리에서 불러왔습니다.');
                
                // 히스토리 섹션 닫기
                elements.historySection.open = false;
            }
        }

        function deleteFromHistory(id) {
            if (confirm('이 항목을 삭제하시겠습니까?')) {
                const history = JSON.parse(localStorage.getItem('summaryHistory') || '[]');
                const filtered = history.filter(h => h.id !== id);
                localStorage.setItem('summaryHistory', JSON.stringify(filtered));
                loadHistory();
            }
        }

        function clearHistory() {
            if (confirm('모든 히스토리를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                localStorage.removeItem('summaryHistory');
                loadHistory();
                updateStatus('🗑️ 히스토리가 모두 삭제되었습니다.');
            }
        }

        // ========== 복사 및 공유 ==========
        async function copyToClipboard(text, type = '텍스트') {
            try {
                await navigator.clipboard.writeText(text);
                updateStatus(`✅ ${type}가 클립보드에 복사되었습니다!`);
            } catch (error) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                updateStatus(`✅ ${type}가 클립보드에 복사되었습니다!`);
            }
        }

        async function shareSummary() {
            const shareData = {
                title: `AI 회의록 요약 - ${currentFileName}`,
                text: elements.result.innerText
            };

            try {
                if (navigator.share && navigator.canShare && navigator.canShare(shareData)) {
                    await navigator.share(shareData);
                    updateStatus('✅ 공유되었습니다!');
                } else {
                    // 공유 링크 생성 (GitHub Pages URL 기준)
                    const url = window.location.href;
                    const shareUrl = `${url}#shared`;
                    await copyToClipboard(shareUrl, '공유 링크');
                    alert('공유 기능을 지원하지 않는 브라우저입니다.\n대신 페이지 URL이 복사되었습니다.');
                }
            } catch (error) {
                console.error('공유 실패:', error);
                updateStatus('❌ 공유에 실패했습니다.');
            }
        }

        // ========== PDF 다운로드 ==========
        async function downloadPdf() {
            const { jsPDF } = window.jspdf;
            const originalStatus = elements.status.innerHTML;
            
            updateStatus('⏳ PDF 생성 중...', true);

            try {
                // HTML2Canvas로 캡처
                const canvas = await html2canvas(elements.result, {
                    scale: 2,
                    useCORS: true,
                    backgroundColor: '#ffffff',
                    logging: false
                });

                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });

                // PDF 설정
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                const contentWidth = pageWidth - (margin * 2);
                
                // 제목 추가
                pdf.setFontSize(20);
                pdf.text('AI 회의록 요약', pageWidth / 2, margin, { align: 'center' });
                
                pdf.setFontSize(10);
                pdf.text(`파일: ${currentFileName}`, margin, margin + 10);
                pdf.text(`생성일: ${new Date().toLocaleString('ko-KR')}`, margin, margin + 15);
                
                // 이미지 추가
                const imgProps = pdf.getImageProperties(imgData);
                const imgHeight = (imgProps.height * contentWidth) / imgProps.width;
                
                let yPosition = margin + 25;
                let remainingHeight = imgHeight;
                
                // 여러 페이지 처리
                while (remainingHeight > 0) {
                    const availableHeight = pageHeight - yPosition - margin;
                    const currentHeight = Math.min(remainingHeight, availableHeight);
                    
                    pdf.addImage(imgData, 'PNG', margin, yPosition, contentWidth, currentHeight);
                    
                    remainingHeight -= currentHeight;
                    
                    if (remainingHeight > 0) {
                        pdf.addPage();
                        yPosition = margin;
                    }
                }

                // 파일 저장
                const safeFileName = currentFileName.replace(/[^a-zA-Z0-9]/g, '_').replace(/\.[^/.]+$/, '');
                pdf.save(`${safeFileName}_summary_${Date.now()}.pdf`);
                
                updateStatus('✅ PDF가 다운로드되었습니다!');
                
            } catch (error) {
                console.error('PDF 생성 오류:', error);
                updateStatus('❌ PDF 생성에 실패했습니다.');
            } finally {
                setTimeout(() => {
                    elements.status.innerHTML = originalStatus;
                }, 3000);
            }
        }

        // ========== 유틸리티 ==========
        function updateStatus(message, showLoader = false) {
            const loaderHtml = showLoader ? '<div class="loader"></div>' : '';
            elements.status.innerHTML = `${loaderHtml}<span>${message}</span>`;
            
            // 접근성을 위한 aria-live
            elements.status.setAttribute('aria-live', 'polite');
            elements.status.setAttribute('aria-busy', showLoader ? 'true' : 'false');
        }

        // ========== Service Worker (오프라인 지원) ==========
        if ('serviceWorker' in navigator && location.protocol === 'https:') {
            // GitHub Pages는 HTTPS이므로 Service Worker 사용 가능
            navigator.serviceWorker.register('sw.js').catch(err => {
                console.log('Service Worker 등록 실패:', err);
            });
        }

        // ========== 전역 함수 (인라인 onclick용) ==========
        window.loadFromHistory = loadFromHistory;
        window.deleteFromHistory = deleteFromHistory;
    </script>
</body>
</html>
